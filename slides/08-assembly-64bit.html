<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>CS 2150: 08-x86 (64 bit) slide set</title>
    <meta name="description" content="A set of slides for a course on Program and Data Representation">
    
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
    <link rel="stylesheet" href="../slides/reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../slides/reveal.js/css/theme/black.css" id="theme">
    <link rel="stylesheet" href="../slides/css/pdr.css">
    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="../slides/reveal.js/lib/css/zenburn.css">
    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? '../slides/reveal.js/css/print/pdf.css' : '../slides/reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
    <!--[if lt IE 9]>
	<script src="../slides/reveal.js/lib/js/html5shiv.js"></script>
	<![endif]-->
    <script type="text/javascript" src="../slides/js/dhtmlwindow.js"></script>
    <script type="text/javascript" src="../slides/js/canvas.js"></script>
    <link rel="stylesheet" href="../slides/css/dhtmlwindow.css" type="text/css">
    <style>.reveal li { font-size:93%; line-height:120%; }</style>
  </head>

  <body onload="canvasinit()">
    <div id="dhtmlwindowholder"><span style="display:none"></span></div>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

	<section data-markdown id="cover"><script type="text/template">
# CS 2150
&nbsp;
### Program and Data Representation
&nbsp;
<center><small><a href="http://www.cs.virginia.edu/~asb">Aaron Bloomfield</a> (aaron@virginia.edu)</small></center>
<center><small><a href="http://@github/uva-cs/pdr">@github</a> | <a href="index.html">&uarr;</a> | <a href="daily-announcements.html?print-pdf"><img class="print" width="20" src="../slides/images/print-icon.png"></a></small></center>

&nbsp;  
&nbsp;  
## 64 bit x86 (assembly language)
	</script></section>

	  <section>
<h2>CS 2150 Roadmap</h2>
<table class="wide">
  <tr><td colspan="3"><p class="center">Data Representation</p></td><td></td><td colspan="3"><p class="center">Program Representation</p></td></tr>
  <tr>
    <td class="top"><small>&nbsp;<br>&nbsp;<br>string<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>int x[3]<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>char x<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>0x9cd0f0ad<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>01101011</small></td>
    <!-- image adapted from http://openclipart.org/detail/3677/arrow-left-right-by-torfnase -->
    <td><img class="noborder" src="images/red-double-arrow.png" height="500" alt="vertical red double arrow"></td>
    <td class="top">&nbsp;<br>Objects<br>&nbsp;<br>Arrays<br>&nbsp;<br>Primitive types<br>&nbsp;<br>Addresses<br>&nbsp;<br>bits</td>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
    <td class="top"><small>&nbsp;<br>&nbsp;<br>Java code<br>&nbsp;<br>&nbsp;<br>C++ code<br>&nbsp;<br>&nbsp;<br>C code<br>&nbsp;<br>&nbsp;<br>x86 code<br>&nbsp;<br>&nbsp;<br>IBCM<br>&nbsp;<br>&nbsp;<br>hexadecimal</small></td>
    <!-- image adapted from http://openclipart.org/detail/3677/arrow-left-right-by-torfnase -->
    <td><img class="noborder" src="images/green-double-arrow.png" height="500" alt="vertical green double arrow"></td>
    <td class="top">&nbsp;<br>High-level language<br>&nbsp;<br>Low-level language<br>&nbsp;<br>Assembly language<br>&nbsp;<br>Machine code</td>
  </tr>
</table>
	  </section>

	<section data-markdown><script type="text/template">
# Contents
&nbsp;  
[Introduction to x86](#/introduction)  
[x86 Instruction Set](#/x86insts)  
[Calling Conventions](#/callingconv)  
[Callee Rules](#/callee)  
[Caller Rules](#/caller)  
[Activation Records](#/actrecs)  
[x86 Examples](#/examples)  
	</script></section>


	<section>

	  <section id="introduction" data-markdown><script type="text/template">
# Introduction to x86
	  </script></section>

	  <section>
<h2>History of x86</h2>
<p><a href="https://en.wikipedia.org/wiki/File:C4004_%28Intel%29.jpg"><img alt="Intel 4004" src="images/08-x86/C4004.jpg"></a></p>
<table class="transparent"><tr><td>
<ul>
<li>1971: 4004, 4-bit words</li>
<li>1972: 8008, 8-bit words</li>
<li>1978: 8086, 16-bit words</li>
<li>1982: 80286</li>
<li>1985: 80386, 32-bit words</li>
<li>1989: 80486</li>
<li>1993: Pentium</li>
<li>1995: Pentium Pro</li>
</ul>
</td><td>
<ul>
<li>1997: Pentium II</li>
<li>1998: Pentium III</li>
<li>2000-2008: Pentium IV</li>
<li>2003: AMD64 Opteron</li>
<li>2004: Intel 64 bit chips</li>
<li>2005-2008: Pentium D</li>
<li>2006-2011: Core 2</li>
<li>2008-present: Core i3, i5, i7</li>
</ul>
</td></tr></table>
	  </section>

	  <section data-markdown><script type="text/template">
## AMD vs Intel
- AMD developed their standard in 2000
  - First chip was available in 2003
- Intel had been working on their IA64 (Itanium) line
  - There is a reason you have never heard of it
- They released their first chip, similar to the AMD64, in 2004
  - But it had slight differences!
- The x86-64 standard is what compilers typically use, and is the intersection of the two instruction sets
  - More than 95% of it is the same
	  </script></section>

	  <section>
<h2>IBCM vs. x86: Registers</h2>
<img src="images/08-x86/registers_x86_64bit.png" class="stretch">
	  </section>

	  <section data-markdown><script type="text/template">
## Funny register names

| &nbsp;&nbsp;8-bit name &nbsp;&nbsp;| &nbsp;&nbsp;16-bit name &nbsp;&nbsp;| &nbsp;&nbsp;32-bit name &nbsp;&nbsp;| &nbsp;&nbsp;64-bit name &nbsp;&nbsp;|
|--|--|--|--|
| a (al/ah) | ax | eax | rax |
| b (bl/bh) | bx | ebx | rbx |
| c (cl/ch) | cx | ecx | rcx |
| d (dl/dh) | dx | edx | rdx |
| - | -  | esi | rsi |
| - | -  | edi | rdi |
| - | sp | esp | rsp |
| - | bp | ebp | rbp |
| - | -  | -   | r8 - r15 |
	  </script></section>

	  <section data-markdown><script type="text/template">
## IBCM vs. x86: Fetch Execute Cycle (same)
```
while(power is on) {
	IR := mem[PC]
	PC := PC + 1 (word) // 64-bits in x86
	execute instruction in IR
}
```
- PC = program counter
- IR = instruction register
	  </script></section>

	  <section>
<h2>Declaring Variables in x86</h2>
<table class="transparent"><tr><td>
<p>Directives</p>
<ul>
<li>byte: 1 byte (DB) declare byte</li>
<li>word: 2 bytes (DW)</li>
<li>double: 4 bytes (DD)</li>
<li>quadword: 8 bytes (DQ)</li>
</ul>
<p>&nbsp;</p>
<p><code>TIMES x DB 0</code> directive means create x bytes of value zero</p>
</td><td>
<pre><code>section .data
a	DB	 	23
b	DW	 	?
c	DD	 	3000
d	DQ	 	-800
x	DD	 	1, 2, 3
y	TIMES 8 DB	0
str	DB	 	'hello', 0
z	TIMES 50 DD	?</code></pre>
</td></tr></table>
	  </section>

	  <section data-markdown><script type="text/template">
## mov command
- `mov <dest>, <src>`
- Where dest and src can be:
  - A register
  - A constant
  - Variable name
  - Pointer: [rbx]
  - *You will often see movq (move quad word) or movl (move double word), etc.
  	- This is more precise as you are declaring how many bytes will be moved, but depends on the assembly syntax used (more on this later)
	  </script></section>

	  <section>
<h2>Addressing Memory</h2>
<table class="transparent"><tr><td class="top">
<ul>
<li>Up to <i>2 registers</i> and one <i>64-bit signed constant</i> can be added together to compute a memory address<br>&nbsp;</li>
<li>Furthermore, one register can be pre-multiplied by 2, 4, or 8<ul>
    <li>word-align</li>
    <li>double-align</li>
    <li>quadword-align</li>
</ul></li></ul>
</td><td style="width:50px"></td><td class="top">
<pre><code>mov rax, rbx
mov rax, [rbx]
mov [var], rbx
mov rax, [r13 - 4]
mov [rsi + rax], cl
mov rdx, [rsi + 4*rbx]</code></pre>
<p>&nbsp;</p>
<p>Incorrect: (why?)</p>
<pre><code>mov rax, [r11 - rcx]
mov [rax + r5 + rdi], rbx
mov [4*rax + 2*rbx], rcx</code></pre>
</td></tr></table>
	  </section>

	  <section>
<table class="transparent"><tr><td class="top">

<table class="transparent">
<tr><td class="top" colspan="3"><h2>Example</h2></td></tr>
<tr><td class="top"><p class="center">Source code:</p><pre><code>mov rcx, rax
mov rdx, [rbx]
mov rsi, [rdx+rax+16]
mov [rsi], 45
mov [a], 15
lea rdi, [a]</code></pre></td>
<td style="width:50px"></td>
<td class="top">
<p class="center">Registers:</p>
<table class="transparent">
<tr><td>rax</td><td class="border" style="width:100px">100</td></tr>
<tr><td>rbx</td><td class="border" style="width:100px">108</td></tr>
<tr><td>rcx</td><td class="border" style="width:100px"><span class="fragment" data-fragment-index="1">100</span></td></tr>
<tr><td>rdx</td><td class="border" style="width:100px"><span class="fragment" data-fragment-index="2">8</span></td></tr>
<tr><td>rsi</td><td class="border" style="width:100px"><span class="fragment" data-fragment-index="3">200</span></td></tr>
<tr><td>rdi</td><td class="border" style="width:100px;border-bottom:medium solid;"><span class="fragment" data-fragment-index="6">300</span></td></tr>
<tr><td>r8</td><td class="border" style="width:100px;border-bottom:medium solid;"></td></tr>
<tr><td>...</td><td class="border" style="width:100px;border-bottom:medium solid;"></td></tr>
</table>
</td></tr></table>

</td><td style="width:50px"></td><td class="top">
<p class="center">Memory:</p>
<table class="transparent">
<tr><td>100</td><td class="border" style="width:100px"></td></tr>
<tr><td>108</td><td class="border" style="width:100px">8</td></tr>
<tr><td>116</td><td class="border" style="width:100px"></td></tr>
<tr><td>124</td><td class="border" style="width:100px">200</td></tr>
<tr><td>132</td><td class="border" style="width:100px"></td></tr>
<tr><td>...</td><td class="border" style="width:100px"></td></tr>
<tr><td>200</td><td class="border" style="width:100px"><span class="fragment" data-fragment-index="4">45</span></td></tr>
<tr><td>208</td><td class="border" style="width:100px"></td></tr>
<tr><td>...</td><td class="border" style="width:100px"></td></tr>
<tr><td>a:&nbsp;300</td><td class="border" style="width:100px"><span class="fragment" data-fragment-index="5">15</span></td></tr>
<tr><td>308</td><td class="border" style="width:100px"></td></tr>
<tr><td>...</td><td class="border" style="width:100px;border-bottom:medium solid;"></td></tr>
</table>
</td></tr></table>
	  </section>

	  <section data-markdown><script type="text/template">
## `mov rax, [4*rsi-rdx]`
1. Valid
2. Invalid
3. Not sure
	  </script></section>

	  <section data-markdown><script type="text/template">
## `mov rax, [4*rsi+4]`
1. Valid
2. Invalid
3. Not sure
	  </script></section>

	  <section data-markdown><script type="text/template">
## `mov rax, [4*rsi+rdx+8]`
1. Valid
2. Invalid
3. Not sure
	  </script></section>

	  <section data-markdown><script type="text/template">
## `mov rax, [rsi+4*rdx]`
1. Valid
2. Invalid
3. Not sure
	  </script></section>

	  <section data-markdown><script type="text/template">
## `mov rax+8, [rsi]`
1. Valid
2. Invalid
3. Not sure
	  </script></section>

	  <section data-markdown><script type="text/template">
## Memory addressing restrictions
- The destination cannot be a constant (duh!)
- You cannot access memory twice in one instruction
  - As the CPU does not have enough time to do so at that clock speed
  - So the following instructions are invalid:
```
mov [rax], [var]
mov [rax+8], [rbx]
mov 20, [rax]
```
	  </script></section>

	</section>

	<section>

	  <section data-markdown id="x86insts"><script type="text/template">
# x86 Instruction Set
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 Instruction Set
- Data movement instructions
- Arithmetic instructions
- Logical instructions
- Control instructions
	  </script></section>

	  <section data-markdown><script type="text/template">
## Data Movement Instructions
- `mov` (or `movq` if you are moving 8 bytes)
  - We've seen this in detail already
- `push`
  - First decrements register RSP (stack pointer) by 8 (stack grows ***down***)
  - push (mov) operand onto stack (8 bytes)
  - sometimes you will see this as pushq (push quad word onto stack)
```
push rax
push [var]
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Data Movement Instructions
- `pop`
  - Pop top element of stack to memory or register, then increment stack pointer (RSP) by 8
  - Value is written to the parameter
```
pop rax
pop [var]
```
- `lea`
  - Load effective address
  - Place address of second parameter into the first parameter
```
lea rax, [var]
lea rdi, [rbx+4*rsi]
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Arithmetic Instructions
- `add`, `sub`
```
add <reg>, <reg>
add <reg>, <mem>
add <mem>, <reg>
add <reg>, <constant>
add <mem>, <constant>
```
  - Adds (or subtracts), storing result in first operand
- Similar restrictions as with data movement instructions:
  - Destination cannot be a constant
  - Memory cannot be accessed twice
	  </script></section>

	  <section data-markdown><script type="text/template">
## Arithmetic Instructions
- `inc`, `dec` (increment and decrement by one)
```
inc <reg>
inc <mem>
```
  - Specific examples:
```
dec rax
inc [var]
```
- `imul`
```
imul <reg64>, <reg64> (or <mem>)
imul <reg64>, <reg64> (or <mem>), <con>
```
- `idiv`
  - Divide 128-bit integer in RDX:RAX by operand
```
idiv rbx
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Logical Instructions
- `and`, `or`, `xor`
```
and <reg>, <reg>
and <reg>, <mem>
and <mem>, <reg>
```
- Specific examples:
```
and rax, 0fH
xor rcx, rcx
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Control Instructions, part 1
- `jmp <label>`
  - go to instruction address specified by label
- `cmp`
  - This must be done prior to an *conditional* jump
  - cmp operand1, operand2
    - Operand1 can be a register or memory (variable)
    - Operand2 can be a register, memory (variable), or a constant
    - Recall that you can't access memory twice!
  - Sets the *machine status word*
	  </script></section>

	  <section data-markdown><script type="text/template">
## Control Instructions, part 2
- Conditional jumps: j*condition*
  - Uses the machine status word, which was set via `cmp`
    - Which holds info about the results of the last instruction
  - There are many 'condition's to determine whether to jump
  - Example: `je <label>`
    - Jump when condition code equal is set
  - Others: `jne`, `jz`, `jg`, `jge`, `jl`, `jle`, `js`, etc.
	  </script></section>

	  <section data-markdown><script type="text/template">
## Control Instructions, part 3
- `call <label>`
  - Subroutine call
  - Pushes address of the *next* instruction onto the stack, then unconditionally jumps to the label
- `ret`
  - Subroutine return
  - Pops the return address from the stack, then jumps to that address
	  </script></section>

	  <section>
<h2>A code block in both C/C++ and Assembly</h2>
<table class="transparent">
<tr><td><p>C/C++ code:</p><pre><code>int n = 5;
int i = 1;
int sum = 0;
while (i &lt;= n) {
    sum += i;
    i++;
}</code></pre></td>
<td style="width:50px"></td>
<td><p>Assembly code:</p><pre><code>section .data
n	DQ 5
i	DQ 1
sum	DQ 0

section .text
loop:  	mov rcx, [i]
	cmp rcx, [n]
	jg endOfLoop
	add [sum], rcx
	inc qword [i]
	jmp loop
endOfLoop:
</code></pre></td></tr></table>
	  </section>

	</section>


	<section>

	  <section id="callingconv" data-markdown><script type="text/template">
# Calling Conventions
	  </script></section>

	  <section data-markdown><script type="text/template">
## Calling of a subroutine
```
int max(int x, int y) {
    int theMax = (x > y) ? x : y;
    return theMax;
}

int main() {
    int a = 5, b = 6;
    int maxVal = max(a,b);
    cout << "Max value: " << maxVal << endl;
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Calling Conventions
- What is a calling convention?
  - A set of rules/expectations between functions
    - How (and where) are *parameters* passed?
    - Which *registers* does the calling function expect to be preserved?
    - Where should *local variables* be stored?
    - How/where should results be *returned* from functions?
- Why?
  - Separate programmers can:
    - Share code more easily
    - Develop libraries 
	  </script></section>

	  <section data-markdown><script type="text/template">
## C Calling Convention
- Why C's calling convention?
  - It's important
  - Is used with both C and C++ code
  - Can enable calling C library functions from assembly code
    - Or other languages, too
	  </script></section>

	  <section data-markdown><script type="text/template">
## C Calling Convention
- Uses hardware stack (memory)
  - Stack *grows down*, toward the lower memory addresses
  - x86 instructions used for calling convention
    - `pop`
    - `push`
    - `call`
    - `ret`
  - Using a stack for calling convention is implemented on most processors.  Why?
    - Recursion
	  </script></section>

	  <section data-markdown><script type="text/template">
## C Calling Convention Overview
- Answers to questions
  - Parameters: passed in registers
  	- If more than 6, then params 7-*n* placed on stack
  	- If passing a large object, then placed on stack (doesn't fit in 64-bit register)
  - Registers: saved on the stack
  - Local variables: placed in memory on the stack
  	- Or in registers if room available
  - Return value: rax register
	  </script></section>

	  <section data-markdown><script type="text/template">
## Calling Convention Overview
- Two sets of rules
  - Caller: the function which calls another function
  - Callee: the function which is called by another function
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller vs. Callee
```
void foo() {
  // some function code ...
}

int main() {
    foo();
    return 0;
}
```

- `main()` is the *caller*
- `foo()` is the *callee*
	  </script></section>

	  <section data-markdown><script type="text/template">
## Register usage
- One register is used for the return value: rax
- Six registers are used for parameter passing:
	- rdi, rsi, rdx, rcx, r8, r9
- Two registers may be modified by the callee: r10 and r11
  - If the caller wants to keep those values, they need to be saved by pushing them onto the stack
  - Actually, these two have specific uses depending on the language, so are often not used for this reason.
- Six registers may not be modified by a subroutine callee:
	- rbx, rbp, r12-r15
        - If it wants to use them, the subroutine must back them up (onto the stack) and restore them later
- rsp should almost never be modified directly, as it points to the top of the stack
	  </script></section>

	  <section data-markdown><script type="text/template">
## Varying number of parameters
- Three ways to have a variable number of parameters:
  - Method overloading
    - `Foo::bar(int)` and `Foo::bar(int, float)`
  - Default parameters
    - `Foo::bar (int x = 3)`
  - Variable arguments
    - As seen next...
	  </script></section>

	  <section data-markdown><script type="text/template">
## Variable number of arguments in C/C++

This code adapted from [here](http://www.cprogramming.com/tutorial/lesson17.html)

```
#include <cstdarg>
#include <iostream>
using namespace std;

double average (int num, ...) {
  va_list arguments;
  double sum = 0;
  va_start (arguments, num);
  for ( int x = 0; x < num; x++ )
    sum += va_arg (arguments, double);
  va_end (arguments);
  return sum / num;
}

int main() {
  cout << average(3, 12.2, 22.3, 4.5) << endl;
  cout << average(5, 3.3, 2.2, 1.1, 5.5, 3.3) << endl;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Dissection of the average() function
- Create a data structure to hold the list of arguments:
```
va_list arguments;
```
- Initialize the arguments to store all values after num:
```
va_start ( arguments, num );
```
- Loop until all numbers are added:
```
for ( int x = 0; x < num; x++ )
```
- Adds the next value in argument list to sum:
```
      sum += va_arg ( arguments, double );
```
- Clean up the list:
```
va_end ( arguments );
```
- Return the average:
```
return sum / num;
```
	  </script></section>


	  <section data-markdown><script type="text/template">
## Example: Output in C
The C equivalent of cout is a function called `printf`
```
printf ("A %s, a %s, a %s: %s!\n", "man", 
		"plan", "canal", "Panama");
printf ("A percent sign: %%\n");
printf ("An int: %d\n", i);
printf ("A float with 2 decimal digits: %.2f\n", 
		float_value);
```
Output:
```
A man, a plan, a canal: Panama!
A percent sign: %
An int: 3
A float with 2 decimal digits: 3.14
```
	  </script></section>

	</section>


	<section>

	  <section id="caller" data-markdown><script type="text/template">
# Caller Rules
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Summary
- Prologue
  - Tasks to take care of BEFORE calling a subroutine
- Call the subroutine with the `call` opcode
- Epilogue
  - Tasks to complete AFTER subroutine call returns
- (It is not really called this, but I use this to parallel the equivalent components in the callee convention)
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Summary
- Prologue
  - Tasks to perform BEFORE executing the function body
- Function body
- Epilogue
  - Tasks to perform AFTER executing function body, but BEFORE leaving function
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules/Responsibilities
- *Before* calling the function (the prologue)
  - Save registers that might be needed after the call (r10, r11, or param registers if applicable)
  - Place parameters in registers / on stack
  	- rdi, rsi, rdx, rcx, r8, r9
  	- Then push extra params onto stack
- *Call* the function
  - `call` instruction places return address on stack
- *After* the called function returns (the epilogue)
  - Remove parameters from stack (if applicable)
  - Restore saved registers (if applicable)
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules ("Prologue")
1. Caller-saved registers
   - Registers which the caller must save (push onto the stack) ONLY if it wants the values preserved.
   - r10, r11, and registers used for parameters if need value saved
2. Parameters
	- First six are passed in through registers (see previous slide)
   - params 7-n pushed in *reverse order* (last parameter first) onto stack
3. Call the subroutine
  - Use the `call` instruction
    - pushes the return address onto the stack and branches to the subroutine
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules ("Epilogue")
1. Remove parameters
   - Parameters pushed onto stack must be removed
     - Restore stack to the state before the call
   - What is done with the parameters?
2. Return value
   - If any, held in rax
3. Restore caller-saved registers
   - `pop` them off the stack (Caller can assume no other registers were modified)
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules Example
We'll see this code in the following slides:
```
long myFunc(long a, long b, long c) {
    long result;
    // some code
    return result;
}

int main() {
    long x = 1, z = 3;
    long retVal = myFunc(x, 123, z);
    //...
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules Example
```
; Want to call a function "myFunc" that takes three
; integer parameters. First parameter is in rax.
; Second parameter is the constant 123. Third
; parameter is in memory location "var"

push rdi         ; rdi will be a param, so saving it

                 ; long retVal = myFunc(x, 123, z);
mov rdi, rax     ; put first param in rdi
mov rsi, 123     ; put second param in rsi
mov rdx, [var]   ; put third param in rdx

call myFunc      ; call the function

pop rdi          ; restore saved rdi value

; return value of myFunc is now available in rax 
; (if there is any return value)
```
	  </script></section>

	  <section>
<h2>Stack Memory Visualization for myFunc</h2>
<p>This is just before the <code>call</code> opcode is invoked.</p>
<hr>
<table class="transparent">
<tr><td>&uarr;</td><td style="width:50px"></td><td class="border" style="width:300px">value of rdi</td><td style="width:25px"></td><td>&larr; rsp</td></tr>
<tr><td>To higher addresses</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0xffffffff)</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To lower addresses</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0x00000000)</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>&darr;</td><td style="width:50px"></td><td class="border" style="width:300px;border-bottom:medium solid;">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
</table>
	  </section>

	  <section data-transition="fade" data-transition-speed="fast">
<h2>Stack Memory Visualization for myFunc</h2>
<p>This is just <i><b>after</b></i> the <code>call</code> opcode is invoked.</p>
<hr>
<table class="transparent">
<tr><td>&uarr;</td><td style="width:50px"></td><td class="border" style="width:300px">value of rdi</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To higher addresses</td><td style="width:50px"></td><td class="border" style="width:300px">return address</td><td style="width:25px"></td><td>&larr; rsp</td></tr>
<tr><td>(to 0xffffffff)</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To lower addresses</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0x00000000)</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>&darr;</td><td style="width:50px"></td><td class="border" style="width:300px;border-bottom:medium solid;">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
</table>
	  </section>

	</section>


	<section>

	  <section id="callee" data-markdown><script type="text/template">
# Callee Rules
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Summary (again)
- Prologue
  - Tasks to perform BEFORE executing the function body
- Function body
- Epilogue
  - Tasks to perform AFTER executing function body, but BEFORE leaving function
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules Example
We will see this code in the following slides:
```
long myFunc(long a, long b, long c) {
    long result;
    // some code
    return result;
}

int main() {
    long x = 1, z = 3;
    long retVal = myFunc(x, 123, z);
    //...
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Rules (Prologue)
Before the body of the function:

1. Allocate local variables
   - Make space on stack (decrement stack pointer)
```
sub rsp, 8
```
That is it. NOTE: caller is also allowed to use valid registers for local variables, so sometimes you will see that instead.


	  </script></section>

	  <section data-markdown id="pushrbp"><script type="text/template">
## PUBLIC SERVICE ANNOUNCEMENT!
- Note that you might see the following:
```
push rbp       ; at the start of the callee
mov rbp, rsp
...
pop rbp        ; just before the ending 'ret'
```
- This is a 32-bit x86 convention that is no longer officially used, but is sometimes seen anyway.
- To omit it, add the `-fomit-frame-pointer` flag to the compilation line
	  </script></section>

	  <section>
<h2>Callee Rules (Prologue)</h2>
<ol start="3">
<li>Save callee-save registers<ul>
    <li>rbx, rbp, r12-r15</li>
    <li>only need to do this if callee intends to use them, otherwise, no need to save their contents</li>
</ul></li></ol>
<p>&nbsp;</p>
<p>THEN, perform body of the function</p>
	  </section>

	  <section data-markdown><script type="text/template">
## Callee Rules (Epilogue)
1. Return value saved to rax
2. Restore callee-saved registers
   - `pop` from stack (in reverse order from which pushed)
3. Deallocate local variables
```
add rsp, 8 //constant here depends on size of locals
```
5. Return
```
ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Rules Example
With a bit more code in the `myFunc()` body (NOTE the use of long here because they are 64-bit):
```
long myFunc(long a, long b, long c) {
    long result;
    result = c;
    result += b;
    return result;
}

int main() {
    long x = 1, z = 3;
    long retVal = myFunc(x, 123, z);
    //...
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Rules Example (1)
```
section .text
myFunc:
                ; prologue
sub rsp, 8      ; room for a 64-bit local var (result)
push rbx        ; save callee-save registers
push rbp        ; both will be used by myFunc
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Rules Example (2)
```
                     ; subroutine body
mov rax, rdi	     ; param 1 to rax
mov rbp, rsi         ; param 2 to rbp
mov rbx, rdx         ; param 3 to rbx
mov [rsp+16], rbx    ; put rbx into local var
add [rsp+16], rbp    ; add rbp into local var
mov rax, [rsp+16]    ; mov contents of local var to rax
                     ; (return value/final result)
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Rules Example (3)
```
                ; subroutine epilogue
pop rbp         ; recover callee save registers
pop rbx         ; REVERSE of when pushed
add rsp, 8      ; deallocate local var(s)
ret             ; pop top value from stack, jump there
```
	  </script></section>

	  <section>
<h2>Stack Memory Visualization for myFunc</h2>
<p>This is just <i>after</i> the caller invokes the <code>call</code> opcode.</p>
<hr>
<table class="transparent">
<tr><td>&uarr;</td><td style="width:50px"></td><td class="border" style="width:300px">value of rdi</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To higher addresses</td><td style="width:50px"></td><td class="border" style="width:300px">return address</td><td style="width:25px"></td><td>&larr; rsp</td></tr>
<tr><td>(to 0xffffffff)</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To lower addresses</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0x00000000)</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>&darr;</td><td style="width:50px"></td><td class="border" style="width:300px;border-bottom:medium solid;">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
</table>
	  </section>

	  <section data-transition="fade" data-transition-speed="fast">
<h2>Stack Memory Visualization for myFunc</h2>
<p>This is just after the callee invokes the <code>sub rsp, 8</code> opcode.</p>
<hr>
<table class="transparent">
<tr><td>&uarr;</td><td style="width:50px"></td><td class="border" style="width:300px">value of rdi</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To higher addresses</td><td style="width:50px"></td><td class="border" style="width:300px">return address</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0xffffffff)</td><td style="width:50px"></td><td class="border" style="width:300px">local var (result)</td><td style="width:25px"></td><td>&larr; rsp</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To lower addresses</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0x00000000)</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>&darr;</td><td style="width:50px"></td><td class="border" style="width:300px;border-bottom:medium solid;">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
</table>
	  </section>

	  <section data-transition="fade" data-transition-speed="fast">
<h2>Stack Memory Visualization for myFunc</h2>
<p>This is after the <code>myFunc()</code> prologue is completed.</p>
<hr>
<table class="transparent">
<tr><td>&uarr;</td><td style="width:50px"></td><td class="border" style="width:300px">value of rdi</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To higher addresses</td><td style="width:50px"></td><td class="border" style="width:300px">return address</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0xffffffff)</td><td style="width:50px"></td><td class="border" style="width:300px">local var (result)</td><td style="width:25px"></td><td>&larr; [rsp+16]</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">value of rbx</td><td style="width:25px"></td><td>&larr; [rsp+8]</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">value of rbp</td><td style="width:25px"></td><td>&larr; [rsp]</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To lower addresses</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0x00000000)</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>&darr;</td><td style="width:50px"></td><td class="border" style="width:300px;border-bottom:medium solid;">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
</table>
	  </section>

	  <section>
    <table class="transparent">
      <tr>
	<td>

	  <!-- code block table -->
	  <small>
	  <table class="transparent">
	    <tr><td><span style="font-size:larger">Code</span></td></tr>
	    <tr><td style="vertical-align:top">
		<table class="transparent" style="padding:0;spacing:0;border-spacing:0;border-collapse:collapse">
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>sub rsp, 8</code></pre></td>         <td><span class="fragment" data-fragment-index="1"><span class="fragment fade-out" data-fragment-index="3"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>push rbx</code></pre></td>     <td><span class="fragment" data-fragment-index="3"><span class="fragment fade-out" data-fragment-index="5"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>push rbp</code></pre></td>       <td><span class="fragment" data-fragment-index="5"><span class="fragment fade-out" data-fragment-index="7"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>mov rax, rdi</code></pre></td>         <td><span class="fragment" data-fragment-index="7"><span class="fragment fade-out" data-fragment-index="9"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>mov rbp, rsi</code></pre></td>         <td><span class="fragment" data-fragment-index="9"><span class="fragment fade-out" data-fragment-index="11"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>mov rbx, rdx</code></pre></td> <td><span class="fragment" data-fragment-index="11"><span class="fragment fade-out" data-fragment-index="13"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>mov [rsp+16], rbx</code></pre></td><td><span class="fragment" data-fragment-index="13"><span class="fragment fade-out" data-fragment-index="15"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>add [rsp+16], rbp</code></pre></td><td><span class="fragment" data-fragment-index="15"><span class="fragment fade-out" data-fragment-index="17"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>mov rax, [rsp+16]</code></pre></td> <td><span class="fragment" data-fragment-index="17"><span class="fragment fade-out" data-fragment-index="19"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>pop rbp</code></pre></td> <td><span class="fragment" data-fragment-index="19"><span class="fragment fade-out" data-fragment-index="21"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>pop rbx</code></pre></td> <td><span class="fragment" data-fragment-index="21"><span class="fragment fade-out" data-fragment-index="23"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>add rsp, 8</code></pre></td>          <td><span class="fragment" data-fragment-index="23"><span class="fragment fade-out" data-fragment-index="25"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>ret</code></pre></td>          <td><span class="fragment" data-fragment-index="25"><span class="fragment fade-out" data-fragment-index="27"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		</table>
	    </td></tr>
	  </table>
	  </small>

	</td>
	<td>

	  <table class="transparent">
	    <tr><td colspan="3"><h2>Callee Animation</h2></td></tr>
	    <tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
	    <tr><td>Stack</td><td colspan="2">Registers</td></tr>
	    <tr>
	      <td style="vertical-align:top">
		<div style="position:relative;left:0;top:0">
		  <img alt="cc animation" class="fragment fade-out" data-fragment-index="2" src="x86/64bit/x86-cc-stack.dot.3.svg" style="position:relative;left:0px;top:0px">
		  <span class="fragment fade-out" data-fragment-index="4"><img alt="cc animation" class="fragment" data-fragment-index="2" src="x86/64bit/x86-cc-stack.dot.4.svg" style="position:absolute;left:0;top:0px"></span>
		  <span class="fragment fade-out" data-fragment-index="6"><img alt="cc animation" class="fragment" data-fragment-index="4" src="x86/64bit/x86-cc-stack.dot.5.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="14"><img alt="cc animation" class="fragment" data-fragment-index="6" src="x86/64bit/x86-cc-stack.dot.6.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="16"><img alt="cc animation" class="fragment" data-fragment-index="14" src="x86/64bit/x86-cc-stack.dot.7.svg" style="position:absolute;left:0;top:0"></span>
		  <img alt="cc animation" class="fragment" data-fragment-index="16" src="x86/64bit/x86-cc-stack.dot.8.svg" style="position:absolute;left:0;top:0">
		</div>
	      </td>
	      
	      <td style="vertical-align:top">
		<div style="position:relative;left:0;top:0">
		  <img alt="cc animation" class="fragment fade-out" data-fragment-index="2" src="x86/64bit/x86-cc-rsp.dot.3.svg" style="position:relative;left:0;top:0">
		  <span class="fragment fade-out" data-fragment-index="4"><img alt="cc animation" class="fragment" data-fragment-index="2" src="x86/64bit/x86-cc-rsp.dot.4.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="6"><img alt="cc animation" class="fragment" data-fragment-index="4" src="x86/64bit/x86-cc-rsp.dot.5.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="20"><img alt="cc animation" class="fragment" data-fragment-index="6" src="x86/64bit/x86-cc-rsp.dot.6.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="22"><img alt="cc animation" class="fragment" data-fragment-index="20" src="x86/64bit/x86-cc-rsp.dot.5.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="24"><img alt="cc animation" class="fragment" data-fragment-index="22" src="x86/64bit/x86-cc-rsp.dot.4.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="26"><img alt="cc animation" class="fragment" data-fragment-index="24" src="x86/64bit/x86-cc-rsp.dot.3.svg" style="position:absolute;left:0;top:0"></span>
		  <img alt="cc animation" class="fragment" data-fragment-index="26" src="x86/64bit/x86-cc-rsp.dot.2.svg" style="position:absolute;left:0;top:0">
		</div>
	      </td>

	      <td style="vertical-align:top">
		<div style="position:relative;left:0;top:0">
		  <img alt="cc animation" class="fragment fade-out" data-fragment-index="8" src="x86/64bit/x86-cc-regs.dot.svg" style="position:relative;left:0;top:0">
		  <span class="fragment fade-out" data-fragment-index="10"><img alt="cc animation" class="fragment" data-fragment-index="8" src="x86/64bit/x86-cc-regs.dot.2.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="12"><img alt="cc animation" class="fragment" data-fragment-index="10" src="x86/64bit/x86-cc-regs.dot.3.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="18"><img alt="cc animation" class="fragment" data-fragment-index="12" src="x86/64bit/x86-cc-regs.dot.4.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="20"><img alt="cc animation" class="fragment" data-fragment-index="18" src="x86/64bit/x86-cc-regs.dot.5.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="22"><img alt="cc animation" class="fragment" data-fragment-index="20" src="x86/64bit/x86-cc-regs.dot.6.svg" style="position:absolute;left:0;top:0"></span>
		  <img alt="cc animation" class="fragment" data-fragment-index="22" src="x86/64bit/x86-cc-regs.dot.7.svg" style="position:absolute;left:0;top:0">
		</div>
	      </td>
	    </tr>
	  </table>

	</td>
      </tr>
    </table>
	  </section>

	  <section data-markdown><script type="text/template">
## That subroutine, again
- We fully realize that the previous assembly method could be written as:
```
mov rax, rdx
add rax, rsi
ret
```
- The long-winded-ness of the previous inefficient version was to show how the calling convention works, not to showcase our assembly writing skills
	  </script></section>


	</section>


	<section>

	  <section id="actrecs" data-markdown><script type="text/template">
# Activation Records
	  </script></section>

	  <section>
<h2>Activation Records</h2>
<table class="transparent"><tr>
<td class="top" style="width:50%">
<ul>
<li>Every time a sub-routine is called, a number of things are (potentially) pushed onto the stack:<ul>
    <li>Registers</li>
    <li>Parameters</li>
    <li>Local variables</li>
    <li>Return address</li>
</ul></li>
<li>All of this is called the <i>activation record</i><ul>
    <li>(note that caller-saved registers are not shown in this diagram)</li>
</ul></li>
</ul>
</td><td style="width:50%">
<img alt="x86 activation record" src="images/08-x86/x86-64bit-activation-record.svg">
</td></tr></table>
	  </section>

	  <section data-markdown><script type="text/template">
## Memory management
- The binary program takes up a fixed amount of space
  - The size of the file (say, 10k, as an example)
- There are two types of memory that need to be handled:
  - Dynamic memory (via `new`, `malloc()`, etc.)
    - This is stored on the *heap*
  - Static memory (on the stack)
    - This is where the activation records are kept
	  </script></section>

	  <section data-markdown><script type="text/template">
## Memory management
- The binary program starts at the beginning of the 2<sup>32</sup> = 4 Gb of memory
- The heap starts right after this
  - Say, at address 10,000 or so if you have a 10 kb binary file
- The stack starts at the end of this 4 Gb of memory, and grows backward
  - They could have chosen the heap to grow backwards, but they didn't
- As a program progresses, they both grow toward the middle
  - And never the two shall meet
	  </script></section>

	  <section>
<h2>Consider this subroutine</h2>
<pre><code>void security_hole() {
    char buffer[12];
    scanf ("%s", buffer); // how C handles input
}</code></pre>
<p>The stack looks like (with sizes in parenthesis):</p>
<table class="transparent" style="border-bottom:medium solid;"><tr>
  <td class="border">&nbsp;rsi (8)&nbsp;</td>
  <td class="border">&nbsp;rdi (8)&nbsp;</td>
  <td class="border">&nbsp;buffer (12)&nbsp;</td>
  <td class="border">&nbsp;ret addr (8)&nbsp;</td>
</tr></table>
<ul>
<li>Addresses increase to the right (the stack grows to the left)</li>
<li class="fragment">What happens if the value stored into buffer is 13 bytes long?</li>
<li class="fragment">What happens if the value stored into buffer is 20 bytes long?<ul>
    <li class="fragment">We overwrite the return address!</li>
</ul></li>
</ul>
	  </section>

	  <section data-markdown><script type="text/template">
## Buffer overflow attack
- When you read in a string (etc.) that goes beyond the size of the buffer
  - Hence 'buffer overflow'
- You can then overwrite the return address
  - And set it to your own code
  - For example, code that is included later on in the string
- We may see an example of this, if there is time in the course...
	  </script></section>

	</section>


	<section>

	  <section id="examples" data-markdown><script type="text/template">
# x86 Examples
	  </script></section>

	  <section data-markdown><script type="text/template">
## A note about x86 compatibility
- We are using nasm as our assembler for the x86 labs
- The x86 code samples in this slide set are either:
  - "Generic" x86 examples that could work in nasm if put into a proper program
    - In the same way that you have seen C++ code snippets
  - Or the output from "clang++ -S" (and some other flags)
    - This code will *NOT* work with nasm, but will work with clang++ (which we aren't really using to compile our assembly anyway)
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 Examples
All examples are in the [slides/code/08-assembly-64bit/](code/08-assembly-64bit/) directory in the github repo  
&nbsp;  
Code we'll see:

- int absolute_value(int x)
- int max(int x, int y)
- bool compare_string(const char \*theStr1, const char \*theStr2)
- int fact(unsigned int n)
	  </script></section>

	  <section data-markdown><script type="text/template">
## int absolute_value(int x)
(see next slide for the source code link)
```
long absolute_value(long x) {
    if ( x < 0 )        // if x is negative
        x = -x;    // negate x
    return x;      // return x
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## test_abs.cpp
Source code: [test_abs.cpp](code/08-assembly-64bit/test_abs.cpp.html) ([src](code/08-assembly-64bit/test_abs.cpp))
```
#include <iostream>
using namespace std;
extern "C" int absolute_value(int x);

long absolute_value(long x) {
    if (x<0)	// if x is negative
        x = -x;	// negate x
    return x;	// return x
}

int main() {
    long theValue=0;
    cout << "Enter a value: " << endl;
    cin >> theValue;
    long theResult = absolute_value(theValue);
    cout << "The result is: " << theResult << endl;
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 Assembly for absolute_value
No external source code; this is how we might write it ourselves.
```
; prologue, nothing here because no saved
; registers and no local vars

; procedure body
mov rax, rdi    	  ; rax <- x
cmp rax, 0            ; x == 0 ?
jge end_of_proc       ; if pos goto end
neg rax               ; negate x

end_of_proc:
				   
; Standard epilogue, no local vars and no saved regs
ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Generating assembly with clang++
- Using the -S flag, we can generate assembly from C/C++ code
- Note that the format is a bit different
  - Register specification, dest/source order, etc.
- So we need to use the following command:
```
clang++ -m64 -S test_abs.cpp -o test_abs-non-intel.s
```
  - You'll see why it has 'non-intel' in the name shortly...
- Actually, we use even more flags...
	  </script></section>

	  <section data-markdown><script type="text/template">
## clang++'s assembly for absolute_value
Note the source / destination order is reversed!  And lots of other differences...

Source code: [test_abs-non-intel.s](code/08-assembly-64bit/test_abs-non-intel.s.html) ([src](code/08-assembly-64bit/test_abs-non-intel.s))
```
absolute_value:
	movq	%rdi, -8(%rsp)
	cmpq	$0, -8(%rsp)
	jge	.LBB1_2
	xorl	%eax, %eax
	movl	%eax, %ecx
	subq	-8(%rsp), %rcx
	movq	%rcx, -8(%rsp)
.LBB1_2:
	movq	-8(%rsp), %rax
	retq
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Assembly differences
- There are a lot of differences between the assembly we've seen and what `clang++ -O2 -S -fomit-frame-pointer` produces
  - The source / destination order is reversed
  - `movq`, `sarq`, `xorq` etc.
    - the 'q' part means 'quadword' (i.e. 64 bits, so the assembler doesn't have to guess)
  - `$0` is the constant 0
  - Register names begin with a percent sign
  - `-8(%rsp)` is [rsp-8]
	  </script></section>

	  <section data-markdown><script type="text/template">
## Assembly syntax "flavors"
- There are two primary syntax "flavors" of x86 assembly
  - The difference is solely in the formatting; all assembly commands can be written in either format
  - You can see more details about the differences [here](https://en.wikipedia.org/wiki/X86_assembly_language#Syntax)
- Flavors:
  - Intel syntax: what we will use, and what nasm uses
  - AT&T syntax: what `clang++ -S` uses by default
- To make clang++ use the Intel syntax, you need to add the <br>`-mllvm --x86-asm-syntax=intel` flags
```
clang++ -m64 -mllvm --x86-asm-syntax=intel -S \
        -fomit-frame-pointer test_abs.cpp -o test_abs.s
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## clang++ flags
- Most of the code in this section uses the following compiler flags: `-m64 -mllvm --x86-asm-syntax=intel -S -fomit-frame-pointer`
- The meanings:
  - `-m64`: create 64-bit code (clang++ sometimes defaults to 32-bit code)
  - `-mllvm --x86-asm-syntax=intel`: this tells clang++ to generate the assembly in the format we are studying
  - `-S`: generates assembly, rather than compiling it into object code (or an executable)
  - `-fomit-frame-pointer`: prevents the push rbp / mov rbp, rsp / pop rbp code discussed [here](#/pushrbp)
- The assembly shown in this slide set was all generated using clang++ (or clang)
	  </script></section>

	  <section data-markdown><script type="text/template">
## clang++'s assembly for absolute_value
This is with the `-mllvm --x86-asm-syntax=intel` flags

Source code: [test_abs.s](code/08-assembly-64bit/test_abs.s.html) ([src](code/08-assembly-64bit/test_abs.s))
```
absolute_value:
	mov	qword ptr [rsp - 8], rdi
	cmp	qword ptr [rsp - 8], 0
	jge	.LBB1_2
	xor	eax, eax
	mov	ecx, eax
	sub	rcx, qword ptr [rsp - 8]
	mov	qword ptr [rsp - 8], rcx
.LBB1_2:
	mov	rax, qword ptr [rsp - 8]
	ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## clang++'s assembly output on Macs
- clang++ may not support the `-mllvm --x86-asm-syntax=intel` flags
  - Can anybody test this?
- So you may be stuck using the "other" format
  - With the source / destination order reversed
- You can compile it on a the Linux VirtualBox image, if you want the 'correct' order
  - We recommned this for the x86 labs!
	  </script></section>

	  <section data-markdown><script type="text/template">
## clang++'s assembly for ints
This is for [test_abs_int.cpp](code/08-assembly-64bit/test_abs_int.cpp.html), which uses `int` types instead of `long` types

Source code: [test_abs_int.s](code/08-assembly-64bit/test_abs_int.s.html) ([src](code/08-assembly-64bit/test_abs_int.s))
```
absolute_value:
	mov	dword ptr [rsp - 4], edi
	cmp	dword ptr [rsp - 4], 0
	jge	.LBB1_2
	xor	eax, eax
	sub	eax, dword ptr [rsp - 4]
	mov	dword ptr [rsp - 4], eax
.LBB1_2:
	mov	eax, dword ptr [rsp - 4]
	ret
```
Note the use of eax instead of rax, and that the offets are `[rsp-4]` rather than `[rsp-8]`
	  </script></section>

	  <section data-markdown><script type="text/template">
## test_abs_c.c
Source code: [test_abs_c.c](code/08-assembly-64bit/test_abs_c.c.html) ([src](code/08-assembly-64bit/test_abs_c.c)); we're back to using `long` types again
```
#include <stdio.h>

long absolute_value(long x) {
    if (x<0)	// if x is negative
        x = -x;	// negate x
    return x;	// return x
}

int main() {
    long theValue=0;
    printf ("Enter a value: \n");
    scanf ("%ld", &theValue);
    long theResult = absolute_value(theValue);
    printf ("The result is: %ld\n", theResult);
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## C++ assembly vs. C assembly
- Notice how much cleaner C translates into assembly versus C++
- Compare the absolute value code in both C and C++:
  - C++: [test_abs.s](code/08-assembly-64bit/test_abs.s.html) ([src](code/08-assembly-64bit/test_abs.s))
  - C: [test_abs_c.s](code/08-assembly-64bit/test_abs_c.s.html) ([src](code/08-assembly-64bit/test_abs_c.s))
	  </script></section>

	  <section data-markdown id="max"><script type="text/template">
## int max(int x, int y)
(see next slide for the source code link)
```
int max(int x, int y) {
    int theMax;
    if (x > y)        // if x > y then x is max
        theMax = x;
    else              // else y is the max
        theMax = y;
    return theMax;    // return the max
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## test_max.cpp
Source code: [test_max.cpp](code/08-assembly-64bit/test_max.cpp.html) ([src](code/08-assembly-64bit/test_max.cpp))
```
#include <iostream>
using namespace std;
extern "C" int max(int x, int y);

// the max function from the previous slide

int main() {
    int theValue1=0, theValue2=0;
    cout << "Enter value 1: " << endl;
    cin >> theValue1;
    cout << "Enter value 2: " << endl;
    cin >> theValue2;
    int theResult = max(theValue1, theValue2);
    cout << "The result is: " << theResult << endl;
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 code for max()
Source code: [test_max.s](code/08-assembly-64bit/test_max.s.html) ([src](code/08-assembly-64bit/test_max.s))
```
max:
	mov	dword ptr [rsp - 4], edi
	mov	dword ptr [rsp - 8], esi
	mov	esi, dword ptr [rsp - 4]
	cmp	esi, dword ptr [rsp - 8]
	jle	.LBB1_2
	mov	eax, dword ptr [rsp - 4]
	mov	dword ptr [rsp - 12], eax
	jmp	.LBB1_3
.LBB1_2:
	mov	eax, dword ptr [rsp - 8]
	mov	dword ptr [rsp - 12], eax
.LBB1_3:
	mov	eax, dword ptr [rsp - 12]
	ret
```
- Notes on this on the next slide
	  </script></section>

	  <section data-markdown><script type="text/template">
## Notes on x86 code for max()
- We are using 32-bit registers (eax instead of rax) because the code used `int` types instead of `long` types
  - Likewise, our offsets are 4 bytes instead of 8 bytes: `[rsp-4]` rather than `[rsp-8]`
- This was compiled with the clang++ flags: `-m64 -mllvm --x86-asm-syntax=intel -S -fomit-frame-pointer`
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 code for max() using -O2
Compiled like the previous, but with `-O2`

Source code: [test_max-O2.s](code/08-assembly-64bit/test_max-O2.s.html) ([src](code/08-assembly-64bit/test_max-O2.s))
```
max:
	cmp     edi, esi
	cmovge  esi, edi
	mov     eax, esi
	ret
```
The [cmovg](http://www.asmpedia.org/index.php?title=CMOVG) opcode (conditional move if greater than) will move the greater value into the first parameter; [cmovge](http://www.asmpedia.org/index.php?title=CMOVGE) does the move greater than *or equal to* value

Note that this code uses the 32-bit versions of the registers because the variables were declared as `int` rather than `long`.
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 code without 'extern "C"'
Compiled like the previous, but *without* `-O2`

Source code: [test_max-noextern.s](code/08-assembly-64bit/test_max-noextern.s.html) ([src](code/08-assembly-64bit/test_max-noextern.s))
```
_Z3maxii:
	mov	dword ptr [rsp - 4], edi
	mov	dword ptr [rsp - 8], esi
	mov	esi, dword ptr [rsp - 4]
	cmp	esi, dword ptr [rsp - 8]
	jle	.LBB1_2
	mov	eax, dword ptr [rsp - 4]
	mov	dword ptr [rsp - 12], eax
	jmp	.LBB1_3
.LBB1_2:
	mov	eax, dword ptr [rsp - 8]
	mov	dword ptr [rsp - 12], eax
.LBB1_3:
	mov	eax, dword ptr [rsp - 12]
	ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## C-string Comparison
(see next slide for the source code link)
```
bool compare_string (const char *theStr1, 
                     const char *theStr2) {
    // while *theStr1 is not NULL terminator
    // and the current corresponding bytes are equal
    while( (*theStr1 != NULL) 
            && (*theStr1 == *theStr2) ) {
        theStr1++;        // increment the pointers to 
        theStr2++;        // the next char / byte
    }
    return (*theStr1==*theStr2);
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## test_string_compare.cpp
Source code: [test_string_compare.cpp](code/08-assembly-64bit/test_string_compare.cpp.html) ([src](code/08-assembly-64bit/test_string_compare.cpp))
```
#include <iostream>
#include <string>
using namespace std;

extern "C" bool compare_string(const char* theStr1, 
                               const char* theStr2);

// code for compare_string here

int main() {
    string theValue1, theValue2;
    cout << "Enter string 1: " << endl;
    cin >> theValue1;
    cout << "Enter string 2: " << endl;
    cin >> theValue2;
    bool theResult = compare_string(theValue1.c_str(),
                                    theValue2.c_str());
    cout << "The result is: " << theResult << endl;
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 for compare_string(), 1/2
Compiled like the previous

Source code: [test_string_compare.s](code/08-assembly-64bit/test_string_compare.s.html) ([src](code/08-assembly-64bit/test_string_compare.s))
```
compare_string:
    mov      al, byte ptr [rdi]
    test     al, al
    je       .LBB0_4
    inc      rdi
.LBB0_2:
    movzx    ecx, byte ptr [rsi]
    movzx    edx, al
    cmp      edx, ecx
    jne      .LBB0_5
    inc      rsi
    mov      al, byte ptr [rdi]
    inc      rdi
    test     al, al
    jne      .LBB0_2
    ...

```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 for compare_string(), 2/2
Compiled like the previous

Source code: [test_string_compare.s](code/08-assembly-64bit/test_string_compare.s.html) ([src](code/08-assembly-64bit/test_string_compare.s))
```
.LBB0_4:
    xor      eax, eax
.LBB0_5:
    movzx    ecx, byte ptr [rsi]
    movzx    eax, al
    cmp      eax, ecx
    sete     al
    ret
```
	  </script></section>


	  <section data-markdown id="fact"><script type="text/template">
## int fact()
(see next slide for the source code link)
```
long fact(unsigned int n) {
    if ( n==0 )
        return 1;
    return n * fact(n-1);
}
```
Note that the parameter is `unsigned int` (32-bit), but the return type is `long` (64-bit)
	  </script></section>

	  <section data-markdown><script type="text/template">
## test_fact.cpp
Source code: [test_fact.cpp](code/08-assembly-64bit/test_fact.cpp.html) ([src](code/08-assembly-64bit/test_fact.cpp))
```
#include <iostream>
using namespace std;

extern "C" long fact(unsigned int n);

long fact(unsigned int n) {
    if ( n==0 )
        return 1;
    return n * fact(n-1);
}

int main() {
    unsigned int theValue = 0;
    cout << "Enter value for fact(): " << endl;
    cin >> theValue;
    long theResult = fact(theValue);
    cout << "The result is: " << theResult << endl;
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 assembly for fact(), 1/2
Compiled like the previous.

Source code: [test_fact.s](code/08-assembly-64bit/test_fact.s.html) ([src](code/08-assembly-64bit/test_fact.s))
```
fact:
	sub	rsp, 24
	mov	dword ptr [rsp + 12], edi
	cmp	dword ptr [rsp + 12], 0
	jne	.LBB1_2
	mov	qword ptr [rsp + 16], 1
	jmp	.LBB1_3
        ...
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 assembly for fact(), 2/2
Source code: [test_fact.s](code/08-assembly-64bit/test_fact.s.html) ([src](code/08-assembly-64bit/test_fact.s))
```
.LBB1_2:
	mov	eax, dword ptr [rsp + 12]
	mov	ecx, eax
	mov	eax, dword ptr [rsp + 12]
	sub	eax, 1
	mov	edi, eax
	mov	qword ptr [rsp], rcx
	call   fact
	mov	rcx, qword ptr [rsp]
	imul   rcx, rax
	mov	qword ptr [rsp + 16], rcx
.LBB1_3:
	mov	rax, qword ptr [rsp + 16]
	add	rsp, 24
	ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## An aside: An advantage of little-Endian
- Consider the 32-bit big-Endian word 0x680abcde in memory starting address 1000:
  - In big-Endian:
    - Byte '68' is the most significant; is at address 1000
    - Byte 'de' is the least significant; is at address 1003
  - In little-Endian:
    - Byte 'de' is the most significant; is at address 1000
    - Byte '68' is the least significant; is at address 1003
- Note that, in little-Endian, the entire 32-bit word *and* the 8-bit least significant byte have the same address!
	  </script></section>

	  <section data-markdown><script type="text/template">
## More on little-Endian
- In little-Endian, the entire 32-bit word *and* the 8-bit least significant byte have the same address
- Consider a `movb`, `movw`, or `movl`
  - Moving a 8, 16, and 32 bit quantity, respecitively
  - If you called `movb`, that instruction moves the *least* significant 8 bits of the 32-bit quantity
- Thus, if you are doing one of those moves, the address is the *same*, which makes the CPU addressing routines simpler
- This means integer *casts* are a essentially a no-op
  - To cast an `int` to a `short`, you just take lowest 16 bits, which means you use a `movw` instead of a `movl`
	  </script></section>

	  <section data-markdown><script type="text/template">
## RISC versus CISC
- RISC
  - Reduced instruction set computer
  - Fewer and simpler instructions (maybe 50 or so)
  - Less chip complexity means they can run fast
- CISC
  - Complex instruction set computer
  - More and more complex instructions (300-400 or so)
  - More chip complexity means harder to make run fast
	  </script></section>

    </section>



      </div>

    </div>

    <div id="calibratediv" style="display:none">
      <div id="calibratecanvasdiv">
        <canvas id="calibratecanvas" width="300" height="300">Your browser does not support the canvas tag</canvas>
      </div>
      <p style="text-align:center">Click the center of the target<br><a href="#" onClick="calibratewin.close(); return false">Close window</a></p>
    </div>

    <script src="reveal.js/js/reveal.js"></script>
    <script src="js/settings.js"></script>

  </body>
</html>
