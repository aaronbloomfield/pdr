<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>CS 2150: 01-cpp slide set</title>
    <meta name="description" content="A set of slides for a course on Program and Data Representation">
    
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
    <link rel="stylesheet" href="../slides/reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../slides/reveal.js/css/theme/black.css" id="theme">
    <link rel="stylesheet" href="../slides/css/pdr.css">
    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="../slides/reveal.js/lib/css/zenburn.css">
    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? '../slides/reveal.js/css/print/pdf.css' : '../slides/reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
    <!--[if lt IE 9]>
	<script src="../slides/reveal.js/lib/js/html5shiv.js"></script>
	<![endif]-->
    <script type="text/javascript" src="../slides/js/dhtmlwindow.js"></script>
    <script type="text/javascript" src="../slides/js/canvas.js"></script>
    <link rel="stylesheet" href="../slides/css/dhtmlwindow.css" type="text/css">
    <style>.reveal li { font-size:93%; line-height:120%; }</style>
  </head>

  <body onload="canvasinit()">
    <div id="dhtmlwindowholder"><span style="display:none"></span></div>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

	<section data-markdown><script type="text/template">
# CS 2150
&nbsp;
### Program and Data Representation
&nbsp;
<center><small><a href="http://www.cs.virginia.edu/~asb">Aaron Bloomfield</a> (aaron@virginia.edu)</small></center>
<center><small><a href="http://@github/uva-cs/pdr">@github</a> | <a href="index.html">&uarr;</a> | <a href="daily-announcements.html?print-pdf"><img class="print" width="20" src="../slides/images/print-icon.png"></a></small></center>

&nbsp;  
&nbsp;
## C++
	</script></section>
    <section>
<h2>CS 2150 Roadmap</h2>
<table class="wide">
  <tr><td colspan="3"><p class="center">Data Representation</p></td><td></td><td colspan="3"><p class="center">Program Representation</p></td></tr>
  <tr>
    <td class="top"><small>&nbsp;<br>&nbsp;<br>string<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>int x[3]<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>char x<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>0x9cd0f0ad<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>01101011</small></td>
    <!-- image adapted from http://openclipart.org/detail/3677/arrow-left-right-by-torfnase -->
    <td><img class="noborder" src="images/red-double-arrow.png" height="500" alt="vertical red double arrow"></td>
    <td class="top">&nbsp;<br>Objects<br>&nbsp;<br>Arrays<br>&nbsp;<br>Primitive types<br>&nbsp;<br>Addresses<br>&nbsp;<br>bits</td>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
    <td class="top"><small>&nbsp;<br>&nbsp;<br>Java code<br>&nbsp;<br>&nbsp;<br>C++ code<br>&nbsp;<br>&nbsp;<br>C code<br>&nbsp;<br>&nbsp;<br>x86 code<br>&nbsp;<br>&nbsp;<br>IBCM<br>&nbsp;<br>&nbsp;<br>hexadecimal</small></td>
    <!-- image adapted from http://openclipart.org/detail/3677/arrow-left-right-by-torfnase -->
    <td><img class="noborder" src="images/green-double-arrow.png" height="500" alt="vertical green double arrow"></td>
    <td class="top">&nbsp;<br>High-level language<br>&nbsp;<br>Low-level language<br>&nbsp;<br>Assembly language<br>&nbsp;<br>Machine code</td>
  </tr>
</table>
    </section>
	<section data-markdown><script type="text/template">
# Contents
&nbsp;  
[Introduction to C++](#/intro)  
[Functions](#/functions)  
[Classes](#/classes)  
[Rational Example](#/rational)  
[Pre-Processor](#/preproc)  
[Pointers](#/pointers)  
[Dynamic Memory Allocation](#/dynamic)  
[References](#/references)  
[Parameter Passing](#/parameters)  
[Sample (advanced) code](#/advanced)  
	</script></section>

	<section>

<section data-markdown id="intro"><script type="text/template">
# Introduction to C++
</script></section>

<section data-markdown><script type="text/template">
## Why C++ and not Java?
- It's good to learn a second language
- C++ is widely used
  - Can be more efficient
  - More control
- C++ will let us "get under the hood" more
  - Data and program representation in memory
  - Memory allocation
</script></section>

<section data-markdown><script type="text/template">
## A brief history lesson
- C was created in 1972 by Dennis Ritchie
  - Intended to be terse, quick to write, and efficient
- C++ was created in 1985 by Bjarne Stroustrup
  - Added classes while being backwards compatible
  - Has pretty terrible syntax!
</script></section>

<section data-markdown><script type="text/template">
## Hello World: Java vs. C++
```java
// Java
public class HelloWorld {
    public static void main(String [] args) {
        System.out.println("Hello World!");
    }
}
```
&nbsp;  
```
// C++
#include <iostream>
using namespace std;
int main() {
    cout << "Hello World" << endl;
    return 0;
}
```
</script></section>

<section data-markdown><script type="text/template">
## Differences
- `main()`
- Preprocessor
  - `#include`
- `using namespace std;`
- Output
</script></section>

<section data-markdown><script type="text/template">
## main()
- Not a part of any class
  - called a *function*
- Must be global
- Must have a return type of int
  - By convention, main returns 0
  - You must *ALWAYS* return 0 from main()
</script></section>

<section data-markdown><script type="text/template">
## Preprocessor
- Examples
  - `#include <iostream> // System file`
  - `#include "ListNode.h" // user file`
- What this does
  - Compiler inserts the contents of the file in the place where the `#include` statement appears
</script></section>

<section data-markdown><script type="text/template">
## C++ Compilation Process Overview
1. Preprocess source file
   - handle \#includes and any other \# statements
2. Compile resulting file
3. Link the resulting files from step 2 (more on this later)
</script></section>

<section>
  <h2>using Directive</h2>
  <p>&nbsp;</p>
  <ul>
    <li>Similar to Java's <span class="tt">import</span>
		<ul>
	<li>Uses a namespace, which is somewhat similar to a Java package</li>
	<li>Allows the programmer to not have to type the full namespace name each time</li>
		</ul>
    </li>
  </ul>
  <table class="transparent" style="margin-left:0">
    <tbody>
      <tr>
	<td>&nbsp;</td>
        <td>
	  <pre style="margin-left:0"><code data-trim>// C++
#include &lt;iostream&gt;
using namespace std;
int main() {
    cout &lt;&lt; "Hello World!" 
         &lt;&lt; endl;
    return 0;
}
</code></pre>
	</td>
	<td>
	  <pre><code data-trim>// C++
#include &lt;iostream&gt;
int main() {
    std::cout &lt;&lt; "Hello World!" 
              &lt;&lt; std::endl;
    return 0;
}
</code></pre>
	</td>
      </tr>
    </tbody>
  </table>
</section>

<section data-markdown><script type="text/template">
## I/O
- Basic I/O
```
// use iostream library
#include <iostream>
using namespace std;
int main() {
    int x;
    cout << "Enter a value for x: ";
    cin >> x;
    return 0;
}
```
</script></section>

<section data-markdown><script type="text/template">
## C++ Primitive Types
- int
  - Can be 16, 32, 64 bits depending on the platform
- float
- double
- char
  - C++ generally uses 8 bit ASCII encoding (more on this later)
- bool
</script></section>

<section data-markdown><script type="text/template">
## C++ Operators and Expressions
- if statement
  - In C++, the condition can be either `int` or `bool`
  - Assume `x` is an `int`
  - `if ( x )`
    - This is valid!
  - `if ( x = 0 )`
    - This will *NOT* cause a compiler error in C++!
</script></section>

<section data-markdown><script type="text/template">
## Operators and Expressions
- Loops, same as Java
  - while, for, do while, break, continue
  - Same syntax as well
</script></section>

<section data-markdown><script type="text/template">
## Compiler choice
- In the past we have used g++
  - From GNU's Compiler Collection
- We are now using clang++ (from LLVM)
  - It has *MUCH* better error messages
- Consider:
```
#include <iostream>
using namespace std;
int main() {
    // note the spelling mistake on the next
    // line where 'cout' is spelled 'cotut'
    cotut << "Hello World";
    return 0;
}
```
</script></section>

<section>
  <h2>Error comparison</h2>
  <p>&nbsp;</p>
  <table class="wide">
    <tr><td class="middletrans">g++:</td><td><img width="850" alt="g++ error message" src="images/01-cpp/g++-error-message.png"></td></tr>
    <tr><td class="middletrans">clang++:</td><td><img width="850" alt="clang++ error message" src="images/01-cpp/clang++-error-message.png"></td></tr>
  </table>
</section>

	</section>

	<section>

<section data-markdown id="functions"><script type="text/template">
# Functions
</script></section>

<section data-markdown><script type="text/template">
## Functions
- Methods that are not a member of a class
        #include <iostream>
        using namespace std;
        
        ret_type func_name(int a, int b, ...) {
            <function body>
        }
        
        int main() {
            ...
            z = func_name(x, y, ...);
            ...;
            return 0;
        }
</script></section>

<section>
  <h2>Declaring mutually<br>recursive functions</h2>
<p>Source code: <a href="code/01-cpp/evenodd.cpp.html">evenodd.cpp</a> (<a href="code/01-cpp/evenodd.cpp">src</a>)</p>
  <table class="transparent">
    <tr>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>
	<pre class="fragment"><code data-trim>bool even (int x);</code></pre>
	<pre><code data-trim>bool odd (int x) {
    if ( x == 0 )
        return false;
    else
        return even (x-1);
}
	  </code></pre></td>
		<td>
	<p>&nbsp;</p>
	<pre><code data-trim>bool even (int x) {
    if ( x == 0 )
        return true;
    else
      return odd (x-1);
}
	  </code></pre></td>
    </tr>
  </table>
</section>

<section data-markdown><script type="text/template">
## Function Prototypes
- C++ compiler process files top to bottom
  - order of appearance matters without a **function prototype**
- General form of a prototype:
```
ret_type func_name (int a, int b, ...);
```
- In this context, they are also called *forward declarations*
</script></section>

<section data-markdown><script type="text/template">
## Example
Source code: [cpptest.cpp](code/01-cpp/cpptest.cpp.html) ([src](code/01-cpp/cpptest.cpp))
```
#include <iostream>
using namespace std;

int max(int a, int b);	// prototype

int main() {
    int x=37, y=52;
    cout << max(x,y) << endl;
    return 0;
}

// actual function implementation
int max(int a, int b) { 
    return (a>b) ? a : b;
}
```
</script></section>

	</section>

	<section>

<section data-markdown id="classes"><script type="text/template">
# Classes
</script></section>

<section data-markdown><script type="text/template">
## Java: IntCell.java
Source code: [IntCell.java](code/01-cpp/IntCell.java.html) ([src](code/01-cpp/IntCell.java))
```
public class IntCell {  

    // default constructor
    public IntCell() {
        this(0);
    }

    // one parameter constructor
    public IntCell(int initialValue) {
        storedValue = initialValue;
    }

    // accessor member function
    public int getValue() {
        return storedValue; 
    }

```
</script></section>

<section data-markdown><script type="text/template">
## Java: IntCell.java
Source code: [IntCell.java](code/01-cpp/IntCell.java.html) ([src](code/01-cpp/IntCell.java))
```
    // mutator member function
    public void setValue(int val) {
        storedValue = val; 
    }

    // private data member
    private int storedValue;

    // main()
    public static void main(String [] args) {
        IntCell m1 = new IntCell();
        IntCell m2 = new IntCell(37);
        System.out.println(m1.getValue() + " " + 
                 m2.getValue());
    }
}
```
  </script></section>

<section data-markdown><script type="text/template">
## How Would You Translate This<br>Java Source into C++?
- Need 3 files
  1. Header file that contains class definition: IntCell.h
  2. C++ file that contains class implementation: IntCell.cpp
  3. C++ file that contains a main(): TestIntCell.cpp
- Note the separation of interface and implementation!
</script></section>

<section data-markdown><script type="text/template">
## C++ IntCell: TestIntCell.cpp
Source code: [TestIntCell.cpp](code/01-cpp/TestIntCell.cpp.html) ([src](code/01-cpp/TestIntCell.cpp))
```
#include <iostream>
#include "IntCell.h" 
using namespace std; 

int main( ) { 
    IntCell m1; // calls the default constructor
    IntCell m2( 37 );
    cout << m1.getValue( ) << " "
         << m2.getValue( ) << endl;
    m1 = m2;
    m2.setValue( 40 );
    cout << m1.getValue( ) << " " 
         << m2.getValue( ) << endl;
    return 0;
}
```
</script></section>

<section data-markdown><script type="text/template">
## C++ IntCell: IntCell.h
Source code: [IntCell.h](code/01-cpp/IntCell.h.html) ([src](code/01-cpp/IntCell.h))
```
#ifndef INTCELL_H
#define INTCELL_H

class IntCell {
  public:
    IntCell( int initialValue = 0 );

    int getValue( ) const;
    void setValue( int val );

  private:
    int storedValue;
    int max(int m) const;
};

#endif
```
</script></section>

<section data-markdown><script type="text/template">
## C++ IntCell: IntCell.cpp
Source code: [IntCell.cpp](code/01-cpp/IntCell.cpp.html) ([src](code/01-cpp/IntCell.cpp))
```
#include "IntCell.h" 
using namespace std; // (not really necessary, but...)

IntCell::IntCell( int initialValue ) : 
	      storedValue( initialValue ) { 
}

int IntCell::getValue( ) const { 
    return storedValue; 
}

void IntCell::setValue( int val ) { 
    storedValue = val; 
} 

int IntCell::max(int m) const {
    return (m>storedValue) ? m : storedValue;
}
```
</script></section>

<section data-markdown><script type="text/template">
## C++ IntCell: IntCell.h (again)
Source code: [IntCell.h](code/01-cpp/IntCell.h.html) ([src](code/01-cpp/IntCell.h))
```
#ifndef INTCELL_H
#define INTCELL_H

class IntCell {
  public:
    IntCell( int initialValue = 0 );

    int getValue( ) const;
    void setValue( int val );

  private:
    int storedValue;
    int max(int m) const;
};

#endif
```
</script></section>

<section data-markdown><script type="text/template">
## C++ IntCell: TestIntCell.cpp (again)
Source code: [TestIntCell.cpp](code/01-cpp/TestIntCell.cpp.html) ([src](code/01-cpp/TestIntCell.cpp))
```
#include <iostream>
#include "IntCell.h" 
using namespace std; 

int main( ) {
    IntCell m1; // calls the default constructor
    IntCell m2( 37 );
    cout << m1.getValue( ) << " "
         << m2.getValue( ) << endl;
    m1 = m2;
    m2.setValue( 40 );
    cout << m1.getValue( ) << " " 
         << m2.getValue( ) << endl;
    return 0;
}
```
</script></section>

<section data-markdown><script type="text/template">
## Separate Compilation
![Separate compilation](images/01-cpp/separate-compilation.png)
</script></section>

	</section>

	<section>

<section id="rational" data-markdown><script type="text/template">
# Rational Example
</script></section>

<section data-markdown><script type="text/template">
## The General Conversion Process
1. Create .h file with class definition
   - Member function signatures, no implementations
2. Create .cpp file containing member function implementations
3. Create .cpp file containing `main()`
</script></section>

<section data-markdown><script type="text/template">
## Reminders
- int main()
- Input/Output
  - `#include <iostream>`
  - `using namespace std;`
  - `cout << varName << " " << endl;`
- Class syntax
  - public and private sections
  - semi-colon at the end of class declaration
  - ClassName::
</script></section>

<section data-markdown><script type="text/template">
## We'll see why later, but for now...
- Printing
  - instead of '+' use '<<' to concatenate items to print
- Remove `this` and `new` from conversion
- Using `#ifndef`, `#define`, and `#endif` in the .h files
</script></section>

<section data-markdown><script type="text/template">
## Rational.h
Source code: [Rational.h](code/01-cpp/Rational.h.html) ([src](code/01-cpp/Rational.h))
```
#ifndef RATIONAL_H
#define RATIONAL_H 

class Rational { 
  public: 
    Rational(); // default constructor 
    ~Rational();         // destructor 
    Rational(int numerator, int denominator); 
    void print() const;
    Rational times(Rational b) const;
    Rational plus(Rational b) const;
    Rational reciprocal() const;
    Rational divides(Rational b) const;
  private: 
    int num, den; // the numerator and denominator
    static int gcd(int m, int n);
};

#endif
```
</script></section>

<section data-markdown><script type="text/template">
## Rational.cpp, 1 of 2
Source code: [Rational.cpp](code/01-cpp/Rational.cpp.html) ([src](code/01-cpp/Rational.cpp))
```
#include "Rational.h" 
#include <iostream> 
using namespace std; 

// default constructor: initialize to 0/1
Rational::Rational() : num(0), den(1) { } 

void Rational::print() const {
    if (den == 1)
        cout << num << "" << endl;
    else 
        cout << num << "/" << den << endl;
}
```
</script></section>

<section data-markdown><script type="text/template">
## Rational.cpp, 2 of 2
Source code: [Rational.cpp](code/01-cpp/Rational.cpp.html) ([src](code/01-cpp/Rational.cpp))
```
Rational Rational::times(Rational b) const {
    return Rational(num * b.num, den * b.den); 
}

Rational::Rational(int numerator, int denominator) { 
    if (denominator == 0)
       cout << "Denominator is zero" << endl; 
    int g = gcd(numerator, denominator);
    num = numerator / g; 
    den = denominator / g; 
}
```
</script></section>

<section data-markdown><script type="text/template">
## TestRational.cpp
Source code: [TestRational.cpp](code/01-cpp/TestRational.cpp.html) ([src](code/01-cpp/TestRational.cpp))
```
#include <iostream>
using namespace std;

#include "Rational.h" 

int main() { 
    Rational x, y, z; 
    // 1/2 + 1/3 = 5/6 
    x = Rational(1, 2); 
    y = Rational(1, 3); 
    z = x.plus(y); 
    z.print(); 

    // ... other code very much like above

    return 0;
}
```
</script></section>

<section data-markdown><script type="text/template">
## .h vs. .cpp?
- C++ naming convention
  - .h files are header files
    - function prototypes
    - class definitions
    - macro definitions
  - .cpp files are implementation files
- Definitions may only appear in 1 place
  - compiler errors: "multiply defined XYZ"
</script></section>

	</section>

	<section>

<section id="preproc" data-markdown><script type="text/template">
# Pre-processor
</script></section>

<section data-markdown><script type="text/template">
## Preprocessing
- \#include
  - Direct copy of file specified to location specified
  - In general, only #include .h files.
- \#ifndef
  - "if not defined"
  - Other preprocessor directives: #ifdef, #if
- \#endif
  - Specifies the end of any #if
- \#define
  - Defines a macro (direct text replacement)
```
#define TRUE 0
if(TRUE == 0) {...}
#define MY_OBJECT_H
```
</script></section>

<section data-markdown><script type="text/template">
## #define
- Can define a constant
```
#define PI 3.14159
...
area = PI * r * r;
```
- Can just define an identifier
```
#define FOO
#ifdef FOO   // is true!
// ...
#endif
#ifndef FOO  // is false!
// ...
#endif
```
</script></section>

<section data-markdown><script type="text/template">
## What problems arise?
- odd.h:
```
#include "even.h"
bool odd (int x);
```
- even.h:
```
#include "odd.h"
bool even (int x);
```
</script></section>

<section data-markdown><script type="text/template">
## Preventing #include loops
- odd.h:
```
#ifndef ODD_H
#define ODD_H
#include "even.h"
bool odd (int x);
#endif
```
- even.h:
```
#ifndef EVEN_H
#define EVEN_H
#include "odd.h"
bool even (int x);
#endif
```
</script></section>

	</section>

	<section>

<section id="pointers" data-markdown><script type="text/template">
# Pointers
</script></section>

<section data-markdown><script type="text/template">
## Pointer Variables
- Stores a memory address of another object
  - Can be a primitive type or a class type
</script></section>

<section data-markdown><script type="text/template">
## Examples of Pointers
- `int * x;`
  - pointer to `int`
- `char *y;`
  - pointer to `char`
- `Rational * rPointer;`
  - pointer to `Rational`
</script></section>

<section data-markdown><script type="text/template">
## What Types are These?
- `float * num1;`
- `double num2;`
- `Rational fraction1;`
- `Square * square1;`
- `int num3;`
</script></section>

<section data-markdown><script type="text/template">
## C++ Syntax: * 
- Asterisk: *
  - In a definition
    - defines pointer type
      - `int * x;`
  - In an expression
    - "dereferences"
    - evaluates object to which the pointer points
      - `*x = 2;`
</script></section>

<section data-markdown><script type="text/template">
## C++ Syntax: &
- Ampersand: &
  - In a definition
    - defines a reference type (more on this later)
  - In an expression
    - "address of"
      - `x = &y;`
</script></section>

<section>
<h2>Pointer Variables</h2>
<p>Source code: <a href="code/01-cpp/pointers.cpp.html">pointers.cpp</a> (<a href="code/01-cpp/pointers.cpp">src</a>)</p>
<table class="transparent"><tr><td>
<table class="transparent">
<tr><th>Variable</th><th>Address</th><th>Memory</th></tr>
<tr><td><p class="center"><span class="fragment" data-fragment-index="1">x</span></p></td><td>1000</td><td class="border"><p class="center"><span class="fragment" data-fragment-index="4">1</span></p></td></tr>
<tr><td><p class="center"><span class="fragment" data-fragment-index="2">y</span></p></td><td>1008</td><td class="border"><p class="center"><span class="fragment" data-fragment-index="5">5</span></p></td></tr>
<tr><td><p class="center"><span class="fragment" data-fragment-index="3">x_pointer</span></p></td><td>1016</td><td class="border"><p class="center"><span class="fragment" data-fragment-index="6">1000</span></p></td></tr>
<tr><td></td><td>1024</td><td class="border"><p>&nbsp;</p></td></tr>
<tr><td></td><td>1032</td><td class="border" style="border-bottom:medium solid;"><p>&nbsp;</p></td></tr>
</table>
</td><td></td><td>
<pre><code data-trim>int x = 1;
int y = 5;
int * x_pointer = &amp;x;
cout &lt;&lt; x_pointer;
cout &lt;&lt; *x_pointer;
</code></pre>
</td></tr></table>
<!-- <script type="text/javascript">insertCanvas();</script> -->
</section>

<section>
<h2>x_pointer = &amp;x</h2>
<img class="stretch" alt="Poitner code execution" src="images/01-cpp/pointers-1.png">
</section>

<section data-markdown><script type="text/template">
## Dereferencing and Assigning
Source code: [pointers.cpp](code/01-cpp/pointers.cpp.html) ([src](code/01-cpp/pointers.cpp))

<table class="transparent"><tr><td>
<table class="transparent">
<tr><th>Variable</th><th>Address</th><th>Memory</th></tr>
<tr><td><p class="center">x</p></td><td>7ffd2063d858</td><td class="border"><p class="center"><span class="fragment fade-out" data-fragment-index="1">1</span><span class="fragment fade-in" data-fragment-index="1"><strong class="red">2</strong></span></p></td></tr>
<tr><td><p class="center">y</p></td><td>7ffd2063d860</td><td class="border"><p class="center">5</p></td></tr>
<tr><td></td><td>...</td><td class="border"><p>&nbsp;</p></td></tr>
<tr><td></td><td>...</td><td class="border"><p>&nbsp;</p></td></tr>
<tr><td><p class="center">x_pointer</p></td><td>...</td><td class="border" style="border-bottom:medium solid;"><p class="center">7ffd2063d858</p></td></tr>
</table>
</td><td></td><td>
<pre><code data-trim>*x_pointer = 2;
</code></pre>
<p>This means to dereference x_pointer</p>
</td></tr></table>

</script></section>

<section>
<h2>*x_pointer = 2</h2>
<img class="stretch" alt="Poitner code execution" src="images/01-cpp/pointers-2.png">
</section>

<section data-markdown><script type="text/template">
## x_pointer = &y
Source code: [pointers.cpp](code/01-cpp/pointers.cpp.html) ([src](code/01-cpp/pointers.cpp))
  
<table class="transparent"><tr><td>
<table class="transparent">
<tr><th>Variable</th><th>Address</th><th>Memory</th></tr>
<tr><td><p class="center">x</p></td><td>7ffd2063d858</td><td class="border"><p class="center">2</p></td></tr>
<tr><td><p class="center">y</p></td><td>7ffd2063d860</td><td class="border"><p class="center">5</p></td></tr>
<tr><td></td><td>...</td><td class="border"><p>&nbsp;</p></td></tr>
<tr><td></td><td>...</td><td class="border"><p>&nbsp;</p></td></tr>
<tr><td><p class="center">x_pointer</p></td><td>...</td><td class="border" style="border-bottom:medium solid;"><p class="center">7ffd2063d8<span class="fragment fade-out" data-fragment-index="1">58</span><span class="fragment fade-in" data-fragment-index="1"><strong class="red">60</strong></span></p></td></tr>
</table>
</td><td></td><td>
<pre><code data-trim>x_pointer = &y;
</code></pre>
<p>This means to get the address of y</p>
</td></tr></table>

</script></section>

<section>
<h2>x_pointer = &y</h2>
<img class="stretch" alt="Poitner code execution" src="images/01-cpp/pointers-3.png">
</section>

<section data-markdown><script type="text/template">
## *x_pointer = 3
Source code: [pointers.cpp](code/01-cpp/pointers.cpp.html) ([src](code/01-cpp/pointers.cpp))
  
<table class="transparent"><tr><td>
<table class="transparent">
<tr><th>Variable</th><th>Address</th><th>Memory</th></tr>
<tr><td><p class="center">x</p></td><td>7ffd2063d858</td><td class="border"><p class="center">2</p></td></tr>
<tr><td><p class="center">y</p></td><td>7ffd2063d860</td><td class="border"><p class="center"><span class="fragment fade-out" data-fragment-index="1">5</span><span class="fragment fade-in" data-fragment-index="1"><strong class="red">3</strong></span></p></td></tr>
<tr><td></td><td>...</td><td class="border"><p>&nbsp;</p></td></tr>
<tr><td></td><td>...</td><td class="border"><p>&nbsp;</p></td></tr>
<tr><td><p class="center">x_pointer</p></td><td>...</td><td class="border" style="border-bottom:medium solid;"><p class="center">7ffd2063d860</p></td></tr>
</table>
</td><td></td><td>
<pre><code data-trim>*x_pointer = 3;
</code></pre>
<p>This means to dereference x_pointer</p>
</td></tr></table>
</script></section>

<section>
<h2>*x_pointer = 3</h2>
<img class="stretch" alt="Poitner code execution" src="images/01-cpp/pointers-4.png">
</section>

<section data-markdown><script type="text/template">
## Binky's Pointer Fun
  
<iframe width="720" height="540" src="http://www.youtube.com/embed/UvoHwFvAvQE?rel=0" frameborder="0" allowfullscreen></iframe>

If that doesn't work, try the [direct Youtube link](http://www.youtube.com/watch?v=UvoHwFvAvQE) (Firefox with Flash enabled doesn't work, in particular)
</script></section>

<section data-markdown><script type="text/template">
## What Types are These?
- `char * x;`
- `int **y;`
- `Rational *rNumber1;`
- `Square **blah;`
</script></section>

<section>
<h2>Pointer Pitfalls: Uninitialized Pointers</h2>
<ul><li>Cause runtime errors
<pre><code data-trim>int n = 30;
int * p;
*p = n;    //ERROR!!!
</code></pre>
<ul><li>p does not have a valid memory address!</li>
<li>A common initializer value used by programmers is NULL
<pre><code data-trim>int *p=NULL; // better code, then add code to check 
             // for NULL value
</code></pre>
</li>
</ul></ul>
<script type="text/javascript">insertCanvas();</script>
</section>

<section>
<h2>swap()</h2>
<p>Source code: <a href="code/01-cpp/swap.cpp.html">swap.cpp</a> (<a href="code/01-cpp/swap.cpp">src</a>)</p>
<pre><code data-trim>void swap(int * x, int * y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}</code></pre>
<script type="text/javascript">insertCanvas();</script>
</section>

<section data-markdown><script type="text/template">
## Calling swap()
Source code: [swap.cpp](code/01-cpp/swap.cpp.html) ([src](code/01-cpp/swap.cpp))
```
int main() {
    int a=0;
    int b=3;
    cout << "Before swap(): a: " << a << "b: " 
         << b << endl;
    swap(&b,&a);
    cout << "After swap(): a: " << a << "b: " 
         << b << endl;
    return 0;
}
```
  </script></section>

	</section>

	<section>

<section id="dynamic" data-markdown><script type="text/template">
# Dynamic Memory<br>Allocation
</script></section>

<section data-markdown><script type="text/template">
## Static Memory Allocation
- Amount of space (memory) already known
      // declare array of 10 elements
      int someArray[10];
      
      // pull a value out of the array
      int value1_address = someArray[3];
</script></section>

<section data-markdown><script type="text/template">
## Dynamic Memory Allocation
- Don't know how much memory is needed in advance
- Need to create the space on the fly
- `new`
  - returns a pointer to newly created "thing"
</script></section>

<section data-markdown><script type="text/template">
## Dynamic Arrays, 1 of 2
Source code: [dynamic_allocation.cpp](code/01-cpp/dynamic_allocation.cpp.html) ([src](code/01-cpp/dynamic_allocation.cpp))
```
int main() {
    int n;

    // read in a value from the user
    cout << "Please enter an integer value: " ;
    cin >> n;

    // use the user's input to create an array of int 
    // using new
    int * ages = new int [n];
```
</script></section>

<section data-markdown><script type="text/template">
## Dynamic Arrays, 2 of 2
Source code: [dynamic_allocation.cpp](code/01-cpp/dynamic_allocation.cpp.html) ([src](code/01-cpp/dynamic_allocation.cpp))
```
    // use a loop to prompt the user to initialize array
    for (int i=0; i < n; i++) {
        cout << "Enter a value for ages[ " << i 
             << " ]: ";
        cin >> ages[i];
    }

    // print out the contents of the array
    for(int i=0; i<n; i++) {
        cout << "ages[ " << i << " ]: " << ages[i];

    // finished with the array
    //clean up the memory used by calling delete
    delete [] ages;
    return 0;
}
```
</script></section>

<section data-markdown><script type="text/template">
## Output
  
![Dynamic allocation execution](images/01-cpp/dynamic-allocation-execution.png)
</script></section>

<section data-markdown><script type="text/template">
## C++ Syntax: new
- General form
  - SomeTypePtr = new SomeType;
  - Examples
    - `int * intPointer = new int;`
    - `Rational * rPointer = new Rational;`
    - `int * intPointer2 = new int(0);`
    - `Rational * rp2 = new Rational(1,2);`
</script></section>

<section data-markdown><script type="text/template">
## Memory Management
- Java is *garbage collected*
  - Allocated memory is automatically reclaimed, programmer does not need to think about it
- C++ does not have garbage collection
  - Programmer must reclaim that memory, otherwise that memory can't be used
</script></section>

<section data-markdown><script type="text/template">
## C++ Syntax: delete
- delete 
  - `delete rPointer;`
  - `delete intPointer;`
- delete []
  - `delete [] ages;`
</script></section>

<section data-markdown><script type="text/template">
## delete
Source code: [delete.cpp](code/01-cpp/delete.cpp.html) ([src](code/01-cpp/delete.cpp))
```
#include <iostream>
#include <string>
using namespace std;

int main() {
    string * pointerToString = new string("hi");
    // some code that uses pointerToString here
    delete pointerToString;
    return 0;
}
```
</script></section>

<section data-markdown><script type="text/template">
## Remember this...
- Anything allocated with new **MUST** be deallocated with delete
</script></section>

<section data-markdown><script type="text/template">
## Accessing parts of an object
- For a regular (i.e., non-pointer) object, use a period:
```
Rational r;
r.num = 4;
```
- For a pointer, dereference it first (as `*r` is the object, and `r` is the pointer):
```
Rational *r = new Rational();
(*r).num = 4;
```    
- An equivalent shorthand for the previous line is below (the arrow means "follow the pointer"):
```
r->num = 4;
```    
- References (coming soon) use a period like regular objects
</script></section>

<section data-markdown><script type="text/template">
## Doubly linked lists (lab 2)
- This is the UML diagram from [Lab 2](../labs/lab02/index.html)
![Lab 2 UML diagram](../labs/lab02/list-diagram.png)
</script></section>

<section data-markdown><script type="text/template">
## friend
- Sometimes other classes need access to private data members of another class

```
class ListNode {

public:
    ListNode();                // Constructor

private:
    int value;
    ListNode *next, *previous; // for doubly linked lists

    friend class List;
    friend class ListItr;
};
```
</script></section>

<section data-markdown><script type="text/template">
## Common mistake 1
- Consider a class List with an uninitialized `ListNode*` field `head` that needs to be initialized in the constructor.
- What is wrong with this constructor?  It compiles fine!
```
List() {
    ListNode* head = new ListNode();
}
```
<span class="fragment"> You are creating a local variable 'head' and not accessing the field named 'head'</span>
</script></section>

<section data-markdown><script type="text/template">
## Common mistake 2
- Consider a class List with an uninitialized `ListNode*` field `head` that needs to be initialized in the constructor.
- What is wrong with this constructor?  It compiles fine!
```
List() {
    ListNode temp;
    head = &temp;
}
```
<span class="fragment">You are making the pointer point to a local variable, which is then promptly deallocated</span>
</script></section>

<section data-markdown><script type="text/template">
## Associativity of *
- Consider:
  - `char*  x, y;`
- We can all agree that x is a character pointer (64 bits)
- But what type is y?
  - It's a regular char (8 bits)
- The * is right associative, meaning that the spacing should be:
  - `char  *x, y;`
  - C++ doesn't care about your whitespace...
- This may not be consistent in this course
</script></section>

<section data-markdown><script type="text/template">
## C++ and memory allocation
- Assume `int *x` has been declared
  - And `int y` is from user input
- Consider these separate C++ lines of code:
  - `x = new int[10]; // 40 bytes`
  - `x = new int;     // 4 bytes`
  - `x = new int[y];  // y*4 bytes`
- When they are deleted, how does C++ know how much memory to free up?
</script></section>

<section data-markdown><script type="text/template">
## C++ and memory allocation
Source code: [memory.cpp](code/01-cpp/memory.cpp.html) ([src](code/01-cpp/memory.cpp))  
```
#include <iostream>
using namespace std;

class Foo {
  long x, y;
};

int main() {
    cout << "sizeof(long): " << sizeof(long) << endl;
    cout << "sizeof(Foo): " << sizeof(Foo) << endl;
    Foo *qux = new Foo(), *bar = new Foo();
    cout << "1st Foo: " << qux << endl;
    cout << "2nd Foo: " << bar << endl;
    long diff = ((long)bar)-((long)qux);
    cout << "Difference: " << diff << endl;
    delete qux;
    delete bar;
    return 0;
}
```
</script></section>

<section data-markdown><script type="text/template">
## C++ and memory allocation
Source code: [memory.cpp](code/01-cpp/memory.cpp.html) ([src](code/01-cpp/memory.cpp))  

Result:
```
    sizeof(long): 8
    sizeof(Foo): 16
    1st Foo: 0x1ec4030
    2nd Foo: 0x1ec4050
    Difference: 32
```
  
Why the extra space?  If only 16 bytes are needed for a `Foo`, then why is the 2nd `Foo` 32 bytes beyond the 1st?

- Keep track of how much space was allocated
- Dynamic memory allocation is not so "efficient" at storing data
</script></section>

	</section>

	<section>

<section id="references" data-markdown><script type="text/template">
# References
</script></section>

<section data-markdown><script type="text/template">
## References
- Declaring a reference:
```
List sampleList
List & theList = sampleList;
```
  - Reference to a List object
  - A reference is like a pointer -- it holds an address -- with three primary differences:
    1. Its address cannot change (its address is constant)
    2. It MUST be initialized upon declaration
       - Cannot (easily) be initialized to `NULL`
    3. Has implicit dereferencing
</script></section>

<section data-markdown><script type="text/template">
## swap() with Pointers
Source code: [swap.cpp](code/01-cpp/swap.cpp.html) ([src](code/01-cpp/swap.cpp))
```
void swap(int * x, int * y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}
```
Note that the programmer must specify dereferencing explicitly
    </ul>
</script></section>

<section data-markdown><script type="text/template">
## swap with References
Source code: [swapref.cpp](code/01-cpp/swapref.cpp.html) ([src](code/01-cpp/swapref.cpp))
```
void swap(int & x, int & y) {
    int temp = x;
    x = y;
    y = temp;
}
```
- Dereferencing is implied with each use
- All Java non-primitive types are references
</script></section>

<section data-markdown><script type="text/template">
## Calling swap() with references
Source code: [swapref.cpp](code/01-cpp/swapref.cpp.html) ([src](code/01-cpp/swapref.cpp))
```
int main() {
    int a=0;
    int b=3;
    cout << "Before swap(): a: " << a << "b: "
         << b << endl;
    swap(b,a);
    cout << "After swap(): a: " << a << "b: " 
         << b << endl;
    return 0;
}
```
</script></section>

<section data-markdown><script type="text/template">
## Accessing Members through a Pointer
(no external source code)
```
// #include and using lines omitted for space reasons

class Square {
  public:
    // constructors, etc. would be here
    int sideLength;
};

int main() {
    Square *squarePtr = new Square(1);
    int length = squarePtr->sideLength;
    // equivalent to saying (*squarePtr).sideLength
    return 0;
}
```
</script></section>

<section data-markdown><script type="text/template">
## Accessing Members through a Reference
(no external source code)
```
// #include and using lines omitted for space reasons

class Square {
  public:
    // constructors, etc. would be here
    int sideLength;
};

int main() {
    Square square = Square(1);
    Square & squareRef = square;
    int length = squareRef.sideLength; // uses a period
    return 0;
}
```
</script></section>

<section data-markdown><script type="text/template">
## Accessing Pointers within Objects
(no external source code)
```
// #include and using lines omitted for space reasons

class example1 {
  public:
    int *a;
};

int main() {
  example1 *c = new example1;
  int x = 0;
  (*c).a = &x; // assign address of x
  c->a = &x; // defrerence c, then access a
}
```
</script></section>

<section data-markdown><script type="text/template">
## Pointer/Reference Cheat Sheet

| Location   | *             | &              |
|------------|---------------|----------------|
| Definition | "pointer to"  | "reference to" |
| Statement  | "dereference" | "address of"   |

&nbsp;  
&nbsp;  

Note that `o1->method()` is the same as `(*o1).method()`
</script></section>

	</section>

	<section>

<section id="parameters" data-markdown><script type="text/template">
# Parameter Passing
</script></section>

<section data-markdown><script type="text/template">
## Call By Value
- Actual parameter is copied into formal parameter
```
int max(int a, int b);
void swap (int *x, int *y);
bool compare(Rational left, Rational right);
```
- Can also pass *pointers* by value
</script></section>

<section data-markdown><script type="text/template">
## Call By Reference
- Pass references as parameters
```
void swap (int &x, int &y);
```
- Use when formal parameter should be *able to change the value* of the actual argument
  - This is when references are used (and for return values); nobody bothers to declare one inside method
</script></section>

<section data-markdown><script type="text/template">
## Call By Constant Reference
- Parameters are constant (won't change) and are passed by reference
```
bool compare(const Rational & left, 
               const Rational & right);
```
- Use when there is a *class type* that *cannot be changed* by formal parameter
</script></section>

<section data-markdown><script type="text/template">
## Other parameter passing types
- Call by copy-restore
- Call by name
- Call by need
- Call by macro expansion
</script></section>

<section data-markdown><script type="text/template">
## Return Passing
- Return by value
  - return a copy (possibly a copy of the pointer)
- Return by reference
  - return a reference
- Return by constant reference
</script></section>

<section data-markdown><script type="text/template">
## Review: Dynamic Memory Allocation
- `new`
  - Allocates a new memory location for use
  - Example:
```
Square * ptrToAnotherSquare = new Square(5);
Triangle *ptrToTriangle = new Triangle();
Circle *ptrToCircle = new Circle;
```
- `delete`
  - Reclaims memory allocated with new
  - Example:
```
delete ptrToAnotherSquare;
```
</script></section>

<section data-markdown><script type="text/template">
## The Big Four
- C++ provides these by default
  - Default constructor
  - Copy Constructor
  - Destructor
  - `operator=()`
- There are some issues with the defaults...
</script></section>

<section data-markdown><script type="text/template">
## Default constructor
- Takes in no parameters
- Doesn't do anything by default
- It's just put in there so you can call it without a compiler error:
  - `foo *x = new foo();`
</script></section>

<section data-markdown><script type="text/template">
## Destructors
- Called whenever an object 
  - goes out of scope, or
  - `delete` is called
- Frees up any resources allocated during the use of an object
- Example (only prototype shown): `~IntCell();`
- The purpose is to free up any resources that the object reserved
  - Typically things are allocated via `new`
    - Example: the destructor in List would delete all the ListNodes
  - Can also free up: files, network sockets, etc.
</script></section>

<section data-markdown><script type="text/template">
## Copy Constructor
- Special constructor that creates a new object, initialized to a copy of the same type of object
- Called in the following situations:
  - declaration with initalization
```
IntCell original;
IntCell copy = original; // or IntCell copy(original);
```
  - if object is passed by value into a subroutine
  - if object is returned by value from a subroutine
</script></section>

<section data-markdown><script type="text/template">
## operator=()
- Also known as the copy assignment operator
- Intended to copy the state of original into copy
- Called when = is applied to two objects AFTER both have previously been constructed
```
IntCell original;    // constructor called
IntCell copy;
copy = original;    // operator= called
```
- This is an example of an *operator override*
</script></section>

<section data-markdown><script type="text/template">
## Operator overrides
- In C++, you can override any operators for a given class
- We've seen this already:
  - `cout << i;`
    - `cout` is an object (of the `ostream` class), and defines an `operator<<()` method
  - `cin >> i;` similarly
- If you were to define your own numerical type (say, complex numbers), you could override all the arithmetic operators, so that the following could be valid code:
```
complex c = 3, d(5,4), e;
e = c + d * 3;
cout << e << endl;
```
- This is done for the `string` class, for example
</script></section>

	</section>

	<section>

<section id="advanced" data-markdown><script type="text/template">
# Sample (advanced) code
</script></section>

<section data-markdown><script type="text/template">
## test.h
Source code: [cpptest.cpp](code/01-cpp/cpptest.cpp.html) ([src](code/01-cpp/cpptest.cpp))
```
class test {
    static int idcount;
    const int id;
    int value;
  public:
    test();
    test(int v);
    test(const test& x);
    ~test();
    test& operator=(const test& other);
    friend ostream& operator<<(ostream& out, 
                               const test& f);
};
```
</script></section>

<section data-markdown><script type="text/template">
## test.cpp 1/2
Source code: [cpptest.cpp](code/01-cpp/cpptest.cpp.html) ([src](code/01-cpp/cpptest.cpp))
```
int test::idcount = 0;

test::test() : id (idcount++), value(0) { 
    cout << "calling test(); object created is " << *this
         << "; address is " << this << endl; 
}

test::test(int v) : id (idcount++), value(v) { 
    cout << "calling test(" << v 
         << "); object created is " << *this 
         << "; address is " << this << endl;
}

test::~test() {
    cout << "calling ~test() on " << *this << endl;
}
```
</script></section>

<section data-markdown><script type="text/template">
## test.cpp 2/2
Source code: [cpptest.cpp](code/01-cpp/cpptest.cpp.html) ([src](code/01-cpp/cpptest.cpp))
```
test::test(const test& x) : id(x.id), value(x.value) {
    cout << "calling test(const test&) on " << *this 
         << "; address is " << this << endl;
}

test& test::operator=(const test& other) {
    cout << "calling operator=(" << other << ")" << endl;
    test *tmp = new test(other);  
    return *tmp;
}

ostream& operator<<(ostream& out, const test& f) {
    out << "test[id=" << f.id << ",v=" << f.value << "]";
}
```
</script></section>

<section data-markdown><script type="text/template">
## The one subroutine...
Source code: [cpptest.cpp](code/01-cpp/cpptest.cpp.html) ([src](code/01-cpp/cpptest.cpp))
```
test bar(test param) {
  return test(10);
}
```
</script></section>

<section data-markdown><script type="text/template">
## main() code and output, 1/9
Source code: [cpptest.cpp](code/01-cpp/cpptest.cpp.html) ([src](code/01-cpp/cpptest.cpp))
```
// this does NOT create a test object; instead, it creates
// a function called a() that has no body (and thus C++ 
// defaults it to return 1). Note that there is no output 
// statement from the default constructor.

test a();
cout << "attempted to create a: " << a << endl;

// output:
// attempted to create a: 1
```
</script></section>

<section data-markdown><script type="text/template">
## main() code and output, 2/9
Source code: [cpptest.cpp](code/01-cpp/cpptest.cpp.html) ([src](code/01-cpp/cpptest.cpp))
```
// this does create a test object, calling the default 
// constructor.  Since putting parenthesis in there for 
// creating an object and calling the default constructor 
// has another meaning in C++ (specifically, creating a 
// function),  we have to omit the parenthesis.

cout << "---------------------------------------" << endl;
test aa;
cout << "created aa: " << aa << endl;

// output:
// ---------------------------------------
// calling test(); object created is test[id=0,v=0]; 
                   address is 0xff852a50
// created aa: test[id=0,v=0]
```
</script></section>

<section data-markdown><script type="text/template">
## main() code and output, 3/9
Source code: [cpptest.cpp](code/01-cpp/cpptest.cpp.html) ([src](code/01-cpp/cpptest.cpp))
```
// this creates a test object, calling the specific 
// constructor that takes in a single int value

cout << "---------------------------------------" << endl;
test b(1);
cout << "created b: " << b << endl;

// output:
// ---------------------------------------
// calling test(1); object created is test[id=1,v=1]; 
//                  address is 0xff852a48
// created b: test[id=1,v=1]
```
</script></section>

<section data-markdown><script type="text/template">
## main() code and output, 4/9
Source code: [cpptest.cpp](code/01-cpp/cpptest.cpp.html) ([src](code/01-cpp/cpptest.cpp))
```
// this creates two test objects via pointers and new

cout << "---------------------------------------" << endl;
test *c = new test(2);
cout << "created *c: " << *c << " at " << c << endl;
test *d = new test;
cout << "created *d: " << *d << " at " << d << endl;

// output:
// ---------------------------------------
// calling test(2); object created is test[id=2,v=2]; 
//                  address is 0xa009008
// created *c: test[id=2,v=2] at 0xa009008
// calling test(); object created is test[id=3,v=0]; 
//                 address is 0xa009018
// created *d: test[id=3,v=0] at 0xa009018
```
</script></section>

<section data-markdown><script type="text/template">
## main() code and output, 5/9
Source code: [cpptest.cpp](code/01-cpp/cpptest.cpp.html) ([src](code/01-cpp/cpptest.cpp))
```
// subroutine invocation. The copy constructor is invoked 
// when the actual parameter is copied into the formal 
// parameter. The subroutine then creates test[id=4,v=10].
// The parameter that was copied into the subroutine (via 
// the copy constructor) is then destructed upon exit.

cout << "---------------------------------------" << endl;
cout << "about to invoke subroutine..." << endl;
test e = bar(*c);
cout << "finished invoking subroutine..." << endl;

// output:
// ---------------------------------------
// about to invoke subroutine...
// calling test(const test&) on test[id=2,v=2]; 
//                   address is 0xff852a38
// calling test(10); object created is test[id=4,v=10]; 
//                   address is 0xff852a40
// calling ~test() on test[id=2,v=2]
// finished invoking subroutine...
```
</script></section>

<section data-markdown><script type="text/template">
## main() code and output, 6/9
Source code: [cpptest.cpp](code/01-cpp/cpptest.cpp.html) ([src](code/01-cpp/cpptest.cpp))
```
// because this assignment happens in the same statement
// as the declaration, it invokes the copy constructor

cout << "---------------------------------------" << endl;
test f = b;

// output:
// ---------------------------------------
// calling test(const test&) on test[id=1,v=1]; 
//                     address is 0xff852a30
```
</script></section>

<section data-markdown><script type="text/template">
## main() code and output, 7/9
Source code: [cpptest.cpp](code/01-cpp/cpptest.cpp.html) ([src](code/01-cpp/cpptest.cpp))
```
// we are only deleting one of the dynamically created 
// test objects

cout << "---------------------------------------" << endl;
cout << "about to delete a test object..." << endl;
delete c;

// output:
// ---------------------------------------
// about to delete a test object...
// calling ~test() on test[id=2,v=2]
```
</script></section>

<section data-markdown><script type="text/template">
## main() code and output, 8/9
Source code: [cpptest.cpp](code/01-cpp/cpptest.cpp.html) ([src](code/01-cpp/cpptest.cpp))
```
// because this assignment does NOT happen in the same 
// statement as the declaration, the operator=() 
// subroutine is called.

cout << "---------------------------------------" << endl;
cout << "assignment..." << endl;
aa = b;

// output:
// ---------------------------------------
// assignment...
// calling operator=(test[id=1,v=1])
// calling test(const test&) on test[id=1,v=1]; 
//                     address is 0xa009008
```
</script></section>

<section data-markdown><script type="text/template">
## main() code and output, 9/9
Source code: [cpptest.cpp](code/01-cpp/cpptest.cpp.html) ([src](code/01-cpp/cpptest.cpp))
```
// upon termination of the main() function, all statically
// created test objects are deallocated.

cout << "---------------------------------------" << endl;
cout << "about to leave main..." << endl;

// output:
// ---------------------------------------
// about to leave main...
// calling ~test() on test[id=1,v=1]
// calling ~test() on test[id=4,v=10]
// calling ~test() on test[id=1,v=1]
// calling ~test() on test[id=0,v=0]

// Note that d was created via dynamic memory allocation, 
// so it is not deallcoated by the program. The operating 
// system will clean up the used memory, but it does not 
// call the destructor on d.
```
 </script></section>

	</section>
	
      </div>

    </div>

    <div id="calibratediv" style="display:none">
      <div id="calibratecanvasdiv">
        <canvas id="calibratecanvas" width="300" height="300">Your browser does not support the canvas tag</canvas>
      </div>
      <p style="text-align:center">Click the center of the target<br><a href="#" onClick="calibratewin.close(); return false">Close window</a></p>
    </div>

    <script src="reveal.js/js/reveal.js"></script>
    <script src="js/settings.js"></script>

  </body>
</html>
