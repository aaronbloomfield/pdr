<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>CS 2150: 08-x86 (32 bit) slide set</title>
    <meta name="description" content="A set of slides for a course on Program and Data Representation">
    <meta name="author" content="Aaron Bloomfield">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
    <link rel="stylesheet" href="../slides/reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../slides/reveal.js/css/theme/black.css" id="theme">
    <link rel="stylesheet" href="../slides/css/pdr.css">
    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="../slides/reveal.js/lib/css/zenburn.css">
    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? '../slides/reveal.js/css/print/pdf.css' : '../slides/reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
    <!--[if lt IE 9]>
	<script src="../slides/reveal.js/lib/js/html5shiv.js"></script>
	<![endif]-->
    <script type="text/javascript" src="../slides/js/dhtmlwindow.js"></script>
    <script type="text/javascript" src="../slides/js/canvas.js"></script>
    <link rel="stylesheet" href="../slides/css/dhtmlwindow.css" type="text/css">
  </head>

  <body onload="canvasinit()">
    <div id="dhtmlwindowholder"><span style="display:none"></span></div>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

	<section data-markdown id="cover"><script type="text/template">
# CS 2150
&nbsp;
### Program and Data Representation
&nbsp;
<center><small>[Aaron Bloomfield](http://www.cs.virginia.edu/~asb) / [aaron@virginia.edu](mailto:aaron@virginia.edu) / [@bloomfieldaaron](http://twitter.com/bloomfieldaaron)</small></center>
<center><small>Repository: [github.com/aaronbloomfield/pdr](http://github.com/aaronbloomfield/pdr) / [&uarr;](index.html) / <a href="08-x86.html?print-pdf"><img class="print" width="20" src="images/print-icon.png"></a></small></center>
&nbsp;  
&nbsp;  
## 32 bit x86 (assembly language)
	</script></section>

	  <section>
<h2>CS 2150 Roadmap</h2>
<table class="wide">
  <tr><td colspan="3"><p class="center">Data Representation</p></td><td></td><td colspan="3"><p class="center">Program Representation</p></td></tr>
  <tr>
    <td class="top"><small>&nbsp;<br>&nbsp;<br>string<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>int x[3]<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>char x<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>0x9cd0f0ad<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>01101011</small></td>
    <!-- image adapted from http://openclipart.org/detail/3677/arrow-left-right-by-torfnase -->
    <td><img class="noborder" src="images/red-double-arrow.png" height="500" alt="vertical red double arrow"></td>
    <td class="top">&nbsp;<br>Objects<br>&nbsp;<br>Arrays<br>&nbsp;<br>Primitive types<br>&nbsp;<br>Addresses<br>&nbsp;<br>bits</td>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
    <td class="top"><small>&nbsp;<br>&nbsp;<br>Java code<br>&nbsp;<br>&nbsp;<br>C++ code<br>&nbsp;<br>&nbsp;<br>C code<br>&nbsp;<br>&nbsp;<br>x86 code<br>&nbsp;<br>&nbsp;<br>IBCM<br>&nbsp;<br>&nbsp;<br>hexadecimal</small></td>
    <!-- image adapted from http://openclipart.org/detail/3677/arrow-left-right-by-torfnase -->
    <td><img class="noborder" src="images/green-double-arrow.png" height="500" alt="vertical green double arrow"></td>
    <td class="top">&nbsp;<br>High-level language<br>&nbsp;<br>Low-level language<br>&nbsp;<br>Assembly language<br>&nbsp;<br>Machine code</td>
  </tr>
</table>
	  </section>

	<section data-markdown><script type="text/template">
# Contents
&nbsp;  
[Introduction to x86](#/introduction)  
[x86 Instruction Set](#/x86insts)  
[Calling Conventions](#/callingconv)  
[Callee Rules](#/callee)  
[Caller Rules](#/caller)  
[Activation Records](#/actrecs)  
[x86 Examples](#/examples)  
	</script></section>


	<section>

	  <section id="introduction" data-markdown><script type="text/template">
# Introduction to x86
	  </script></section>

	  <section>
<h2>History of x86</h2>
<p><a href="https://en.wikipedia.org/wiki/File:C4004_%28Intel%29.jpg"><img alt="Intel 4004" src="images/08-x86/C4004.jpg"></a></p>
<table class="transparent"><tr><td>
<ul>
<li>1971: 4004, 4-bit words</li>
<li>1972: 8008, 8-bit words</li>
<li>1978: 8086, 16-bit words</li>
<li>1982: 80286</li>
<li>1985: 80386, 32-bit words</li>
<li>1989: 80486</li>
<li>1993: Pentium</li>
</ul>
</td><td>
<ul>
<li>1995: Pentium Pro</li>
<li>1997: Pentium II</li>
<li>1998: Pentium III</li>
<li>2000-2008: Pentium IV</li>
<li>2005-2008: Pentium D</li>
<li>2006-2011: Core 2</li>
<li>2008-present: Core i3, i5, i7</li>
</ul>
</td></tr></table>
	  </section>

	  <section data-markdown><script type="text/template">
## IBCM vs. x86: Registers
![x86 registers](images/08-x86/x86-register-diagram.svg)
	  </script></section>

	  <section data-markdown><script type="text/template">
## IBCM vs. x86: Fetch Execute Cycle (same)
```
while(power is on) {
	IR := mem[PC]
	PC := PC + 1 (word) // 32-bits in x86
	execute instruction in IR
}
```
- PC = program counter
- IR = instruction register
	  </script></section>

	  <section>
<h2>Declaring Variables in x86</h2>
<table class="transparent"><tr><td>
<p>Directives</p>
<ul>
<li>byte: 1 byte (DB) declare byte</li>
<li>word: 2 bytes (DW)</li>
<li>double: 4 bytes (DD)</li>
<li>quadword: 8 bytes (DQ)</li>
</ul>
<p>&nbsp;</p>
<p><code>TIMES x DB 0</code> directive means create x bytes of value zero</p>
</td><td>
<pre><code>section .data
a	DB	 	23
b	DW	 	?
c	DD	 	3000
d	DQ	 	-800
x	DD	 	1, 2, 3
y	TIMES 8 DB	0
str	DB	 	'hello', 0
z	TIMES 50 DD	?</code></pre>
</td></tr></table>
	  </section>

	  <section data-markdown><script type="text/template">
## mov command
- `mov <dest>, <src>`
- Where dest and src can be:
  - A register
  - A constant
  - Variable name
  - Pointer: [ebx]
  - (but with a few exceptions we'll see shortly)
	  </script></section>

	  <section>
<h2>Addressing Memory</h2>
<table class="transparent"><tr><td class="top">
<ul>
<li>Up to <i>2 registers</i> and one <i>32-bit signed constant</i> can be added together to compute a memory address<br>&nbsp;</li>
<li>Furthermore, one register can be pre-multiplied by 2, 4, or 8<ul>
    <li>word-align</li>
    <li>double-align</li>
    <li>quadword-align</li>
</ul></li></ul>
</td><td style="width:50px"></td><td class="top">
<pre><code>mov eax, ebx
mov eax, [ebx]
mov [var], ebx
mov eax, [esi - 4]
mov [esi + eax], cl
mov edx, [esi + 4*ebx]</code></pre>
<p>&nbsp;</p>
<p>Incorrect: (why?)</p>
<pre><code>mov eax, [ebx - ecx]
mov [eax + esi + edi], ebx
mov [4*eax + 2*ebx], ecx</code></pre>
</td></tr></table>
	  </section>

	  <section>
<table class="transparent"><tr><td class="top">

<table class="transparent">
<tr><td class="top" colspan="3"><h2>Example</h2></td></tr>
<tr><td class="top"><p class="center">Source code:</p><pre><code>mov ecx, eax
mov edx, [ebx]
mov esi, [edx+eax+4]
mov [esi], 45
mov [a], 15
lea edi, [a]</code></pre></td>
<td style="width:50px"></td>
<td class="top">
<p class="center">Registers:</p>
<table class="transparent">
<tr><td>eax</td><td class="border" style="width:100px">100</td></tr>
<tr><td>ebx</td><td class="border" style="width:100px">104</td></tr>
<tr><td>ecx</td><td class="border" style="width:100px"><span class="fragment" data-fragment-index="1">100</span></td></tr>
<tr><td>edx</td><td class="border" style="width:100px"><span class="fragment" data-fragment-index="2">8</span></td></tr>
<tr><td>esi</td><td class="border" style="width:100px"><span class="fragment" data-fragment-index="3">200</span></td></tr>
<tr><td>edi</td><td class="border" style="width:100px;border-bottom:medium solid;"><span class="fragment" data-fragment-index="6">300</span></td></tr>
</table>
</td></tr></table>

</td><td style="width:50px"></td><td class="top">
<p class="center">Memory:</p>
<table class="transparent">
<tr><td>100</td><td class="border" style="width:100px"></td></tr>
<tr><td>104</td><td class="border" style="width:100px">8</td></tr>
<tr><td>108</td><td class="border" style="width:100px"></td></tr>
<tr><td>112</td><td class="border" style="width:100px">200</td></tr>
<tr><td>116</td><td class="border" style="width:100px"></td></tr>
<tr><td>...</td><td class="border" style="width:100px"></td></tr>
<tr><td>200</td><td class="border" style="width:100px"><span class="fragment" data-fragment-index="4">45</span></td></tr>
<tr><td>204</td><td class="border" style="width:100px"></td></tr>
<tr><td>...</td><td class="border" style="width:100px"></td></tr>
<tr><td>a:&nbsp;300</td><td class="border" style="width:100px"><span class="fragment" data-fragment-index="5">15</span></td></tr>
<tr><td>304</td><td class="border" style="width:100px"></td></tr>
<tr><td>...</td><td class="border" style="width:100px;border-bottom:medium solid;"></td></tr>
</table>
</td></tr></table>
	  </section>

	  <section data-markdown><script type="text/template">
## `mov eax, [4*esi-edx]`
1. Valid
2. Invalid
3. Not sure
	  </script></section>

	  <section data-markdown><script type="text/template">
## `mov eax, [4*esi+4]`
1. Valid
2. Invalid
3. Not sure
	  </script></section>

	  <section data-markdown><script type="text/template">
## `mov eax, [4*esi+edx+8]`
1. Valid
2. Invalid
3. Not sure
	  </script></section>

	  <section data-markdown><script type="text/template">
## `mov eax, [esi+4*edx]`
1. Valid
2. Invalid
3. Not sure
	  </script></section>

	  <section data-markdown><script type="text/template">
## `mov eax+4, [esi]`
1. Valid
2. Invalid
3. Not sure
	  </script></section>

	  <section data-markdown><script type="text/template">
## Memory addressing restrictions
- The destination cannot be a constant (duh!)
- You cannot access memory twice in one instruction
  - As the CPU does not have enough time to do so at that clock speed
  - So the following instructions are invalid:
```
mov [eax], [var]
mov [eax+4], [ebx]
mov 20, [eax]
```
	  </script></section>

	</section>

	<section>

	  <section data-markdown id="x86insts"><script type="text/template">
# x86 Instruction Set
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 Instruction Set
- Data movement instructions
- Arithmetic instructions
- Logical instructions
- Control instructions
	  </script></section>

	  <section data-markdown><script type="text/template">
## Data Movement Instructions, part 1
- `mov`
  - We've seen this in detail already
- `push`
  - First decrements ESP (stack pointer) by 4 (stack grows ***down***)
  - push (mov) operand onto stack (4 bytes)
```
push eax
push [var]
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Data Movement Instructions, part 2
- `pop`
  - Pop top element of stack to memory or register, then increment stack pointer (ESP) by 4
  - Value is written to the parameter
```
pop eax
pop [var]
```
- `lea`
  - Load effective address
  - Place address of second parameter into the first parameter
```
lea eax, [var]
lea edi, [ebx+4*esi]
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Arithmetic Instructions, part 1
- `add`, `sub`
```
add <reg>, <reg>
add <reg>, <mem>
add <mem>, <reg>
add <reg>, <constant>
add <mem>, <constant>
```
  - Adds (or subtracts), storing result in first operand
- Similar restrictions as with data movement instructions:
  - Destination cannot be a constant
  - Memory cannot be accessed twice
	  </script></section>

	  <section data-markdown><script type="text/template">
## Arithmetic Instructions, part 2
- `inc`, `dec` (increment and decrement by one)
```
inc <reg>
inc <mem>
```
  - Specific examples:
```
dec eax
inc [var]
```
- `imul`
```
imul <reg32>, <reg32> (or <mem>)
imul <reg32>, <reg32> (or <mem>), <con>
```
- `idiv`
  - Divide 64-bit integer in EDX:EAX by operand
```
idiv ebx
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Logical Instructions
- `and`, `or`, `xor`
```
and <reg>, <reg>
and <reg>, <mem>
and <mem>, <reg>
```
- Specific examples:
```
and eax, 0fH
xor ecx, ecx
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Control Instructions, part 1
- `jmp <label>`
  - go to instruction address specified by label
- `cmp`
  - This must be done prior to an *conditional* jump
  - cmp operand1, operand2
    - Operand1 can be a register or memory (variable)
    - Operand2 can be a register, memory (variable), or a constant
    - Recall that you can't access memory twice!
  - Sets the *machine status word*
	  </script></section>

	  <section data-markdown><script type="text/template">
## Control Instructions, part 2
- Conditional jumps: j*condition*
  - Uses the machine status word, which was set via `cmp`
    - Which holds info about the results of the last instruction
  - There are many 'condition's to determine whether to jump
  - Example: `je <label>`
    - Jump when condition code equal is set
  - Others: `jne`, `jz`, `jg`, `jge`, `jl`, `jle`, `js`, etc.
	  </script></section>

	  <section data-markdown><script type="text/template">
## Control Instructions, part 3
- `call <label>`
  - Subroutine call
  - Pushes address of the *next* instruction onto the stack, then unconditionally jumps to the label
- `ret`
  - Subroutine return
  - Pops the return address from the stack, then jumps to that address
	  </script></section>

	  <section>
<h2>A code block in both C/C++ and Assembly</h2>
<table class="transparent">
<tr><td><p>C/C++ code:</p><pre><code>int n = 5;
int i = 1;
int sum = 0;
while (i &lt;= n) {
    sum += i;
    i++;
}</code></pre></td>
<td style="width:50px"></td>
<td><p>Assembly code:</p><pre><code>section .data
n	DD 5
i	DD 1
sum	DD 0

section .text
loop:  	mov ecx, [i]
	cmp ecx, [n]
	jg endOfLoop
	add [sum], ecx
	inc [i]
	jmp loop
endOfLoop:
</code></pre></td></tr></table>
	  </section>

	</section>


	<section>

	  <section id="callingconv" data-markdown><script type="text/template">
# Calling Conventions
	  </script></section>

	  <section data-markdown><script type="text/template">
## Calling of a subroutine
```
int max(int x, int y) {
    int theMax = (x > y) ? x : y;
    return theMax;
}

int main() {
    int a = 5, b = 6;
    int maxVal = max(a,b);
    cout << "Max value: " << maxVal << endl;
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Calling Conventions
- What is a calling convention?
  - A set of rules/expectations between functions
    - How (and where) are *parameters* passed?
    - Which *registers* does the calling function expect to be preserved?
    - Where should *local variables* be stored?
    - How/where should results be *returned* from functions?
- Why?
  - Separate programmers can:
    - Share code more easily
    - Develop libraries 
	  </script></section>

	  <section data-markdown><script type="text/template">
## C Calling Convention
- Why C's calling convention?
  - It's important
  - Is used with both C and C++ code
  - Can enable calling C library functions from assembly code
    - Or other languages, too
	  </script></section>

	  <section data-markdown><script type="text/template">
## C Calling Convention
- Uses hardware stack (memory)
  - Stack *grows down*, toward the lower memory addresses
  - x86 instructions used for calling convention
    - `pop`
    - `push`
    - `call`
    - `ret`
  - Using a stack for calling convention is implemented on most processors.  Why?
    - Recursion
	  </script></section>

	  <section data-markdown><script type="text/template">
## C Calling Convention Overview
- Answers to questions
  - Parameters: passed on the stack
  - Registers: saved on the stack
  - Local variables: placed in memory on the stack
  - Return value: eax register
	  </script></section>

	  <section data-markdown><script type="text/template">
## Calling Convention Overview
- Two sets of rules
  - Caller: the function which calls another function
  - Callee: the function which is called by another function
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller vs. Callee
```
void foo() {
  // some function code ...
}

int main() {
    foo();
    return 0;
}
```

- `main()` is the *caller*
- `foo()` is the *callee*
	  </script></section>

	  <section data-markdown><script type="text/template">
## Register usage
- One register is used for the return value: eax
- Three registers may be modified by the callee: eax, ecx, edx
  - If the caller wants to keep those values, they need to be saved by pushing them onto the stack
  - And note eax is where the return value goes
- Three registers may not be modified by a subroutine call: ebx, edi, esi
  - If the subroutine wants to modify them, it needs to back them up first (onto the stack) and restore them before returning
- Two registers should almost never be modified directly: ebp, esp
  - There is an exception: ebp is modified in one case by the callee
	  </script></section>

	  <section data-markdown><script type="text/template">
## Varying number of parameters
- Three ways to have a variable number of parameters:
  - Method overloading
    - `Foo::bar(int)` and `Foo::bar(int, float)`
  - Default parameters
    - `Foo::bar (int x = 3)`
  - Variable arguments
    - As seen next...
	  </script></section>

	  <section data-markdown><script type="text/template">
## Variable number of arguments in C/C++

This code adapted from [here](http://www.cprogramming.com/tutorial/lesson17.html)

```
#include <cstdarg>
#include <iostream>
using namespace std;

double average (int num, ...) {
  va_list arguments;
  double sum = 0;
  va_start (arguments, num);
  for ( int x = 0; x < num; x++ )
    sum += va_arg (arguments, double);
  va_end (arguments);
  return sum / num;
}

int main() {
  cout << average(3, 12.2, 22.3, 4.5) << endl;
  cout << average(5, 3.3, 2.2, 1.1, 5.5, 3.3) << endl;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Dissection of the average() function
- Create a data structure to hold the list of arguments:
```
va_list arguments;
```
- Initialize the arguments to store all values after num:
```
va_start ( arguments, num );
```
- Loop until all numbers are added:
```
for ( int x = 0; x < num; x++ )
```
- Adds the next value in argument list to sum:
```
      sum += va_arg ( arguments, double );
```
- Clean up the list:
```
va_end ( arguments );
```
- Return the average:
```
return sum / num;
```
	  </script></section>


	  <section data-markdown><script type="text/template">
## Example: Output in C
The C equivalent of cout is a function called `printf`
```
printf ("A %s, a %s, a %s: %s!\n", "man", 
		"plan", "canal", "Panama");
printf ("A percent sign: %%\n");
printf ("An int: %d\n", i);
printf ("A float with 2 decimal digits: %.2f\n", 
		float_value);
```
Output:
```
A man, a plan, a canal: Panama!
A percent sign: %
An int: 3
A float with 2 decimal digits: 3.14
```
	  </script></section>

	</section>


	<section>

	  <section id="caller" data-markdown><script type="text/template">
# Caller Rules
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Summary
- Prologue
  - Tasks to take care of BEFORE calling a subroutine
- Call the subroutine with the `call` opcode
- Epilogue
  - Tasks to complete AFTER subroutine call returns
- (It is not really called this, but I use this to parallel the equivalent components in the callee convention)
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Summary
- Prologue
  - Tasks to perform BEFORE executing the function body
- Function body
- Epilogue
  - Tasks to perform AFTER executing function body, but BEFORE leaving function
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules/Responsibilities
- *Before* calling the function (the prologue)
  - Save registers that might be needed after the call (eax, ecx, edx)
  - Push parameters on the stack
- *Call* the function
  - `call` instruction places return address in stack
- *After* the called function returns (the epilogue)
  - Remove parameters from stack
  - Restore saved registers
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules ("Prologue")
1. Caller-saved registers
   - Registers which the calling function (caller) must save (push onto the stack) ONLY if it wants the values preserved.
   - eax, ecx, edx
2. Parameters
   - Pushed in *reverse order* (last parameter first) onto stack
3. Call the subroutine
  - Use the `call` instruction
    - pushes the return address onto the stack and branches to the subroutine
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules ("Epilogue")
1. Remove parameters
   - Parameters pushed onto stack must be removed
     - Restore stack to the state before the call
   - What is done with the parameters?
2. Return value
   - If any, held in eax
3. Restore caller-saved registers
   - eax, ecx, edx
   - `pop` them off the stack (Caller can assume no other registers were modified)
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules Example
We'll see this code in the following slides:
```
int myFunc(int a, int b, int c) {
    int result;
    // some code
    return result;
}

int main() {
    int x = 1, z = 3;
    int retVal = myFunc(x, 123, z);
    //...
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules Example
```
push edx         ; caller wants edx to be preserved

                 ; int retVal = myFunc(x, 123, z);
push [z]         ; Push last param first
push 123         ; push constant 123
push eax         ; push first param last

call myFunc      ; call the function

add esp, 12      ; clean up stack
pop edx          ; restore saved edx value

; return value of myFunc is now available in eax 
; (if there is any return value)
```
	  </script></section>

	  <section>
<h2>Stack Memory Visualization for myFunc</h2>
<p>This is just before the <code>call</code> opcode is invoked.</p>
<hr>
<table class="transparent">
<tr><td>&uarr;</td><td style="width:50px"></td><td class="border" style="width:300px">value of edx</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To higher addresses</td><td style="width:50px"></td><td class="border" style="width:300px">copy of var z</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0xffffffff)</td><td style="width:50px"></td><td class="border" style="width:300px">123</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">value of eax (var x)</td><td style="width:25px"></td><td>&larr; esp</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To lower addresses</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0x00000000)</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>&darr;</td><td style="width:50px"></td><td class="border" style="width:300px;border-bottom:medium solid;">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
</table>
	  </section>

	  <section data-transition="fade" data-transition-speed="fast">
<h2>Stack Memory Visualization for myFunc</h2>
<p>This is just <i><b>after</b></i> the <code>call</code> opcode is invoked.</p>
<hr>
<table class="transparent">
<tr><td>&uarr;</td><td style="width:50px"></td><td class="border" style="width:300px">value of edx</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To higher addresses</td><td style="width:50px"></td><td class="border" style="width:300px">copy of var z</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0xffffffff)</td><td style="width:50px"></td><td class="border" style="width:300px">123</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">value of eax (var x)</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">return address</td><td style="width:25px"></td><td>&larr; esp</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To lower addresses</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0x00000000)</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>&darr;</td><td style="width:50px"></td><td class="border" style="width:300px;border-bottom:medium solid;">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
</table>
	  </section>

	</section>


	<section>

	  <section id="callee" data-markdown><script type="text/template">
# Callee Rules
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Summary (again)
- Prologue
  - Tasks to perform BEFORE executing the function body
- Function body
- Epilogue
  - Tasks to perform AFTER executing function body, but BEFORE leaving function
	  </script></section>

	  <section data-markdown><script type="text/template">
## Caller Rules Example
We'll see this code in the following slides:
```
int myFunc(int a, int b, int c) {
    int result;
    // some code
    return result;
}

int main() {
    int x = 1, z = 3;
    int retVal = myFunc(x, 123, z);
    //...
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Rules (Prologue)
Before the body of the function:

1. Push ebp and copy esp into ebp
```
push ebp
mov ebp, esp
```
  - ebp: snapshot of esp when subroutine starts
    - Parameters and local variables are known distances/offsets from this pointer value
2. Allocate local variables
   - Make space on stack (decrement stack pointer)
```
sub esp, 4
```
	  </script></section>

	  <section>
<h2>Callee Rules (Prologue)</h2>
<ol start="3">
<li>Save callee-save registers<ul>
    <li>ebx, edi, esi (push them onto stack)</li>
    <li>only need to do this if callee intends to use them, otherwise, no need to save their contents</li>
</ul></li></ol>
<p>&nbsp;</p>
<p>THEN, perform body of the function</p>
	  </section>

	  <section data-markdown><script type="text/template">
## Callee Rules (Epilogue)
1. Return value saved to eax
2. Restore callee-saved registers
   - `pop` from stack (in reverse order from which pushed)
3. Deallocate local variables
```
mov esp, ebp
```
4. Restore base pointer
```
pop ebp
```
5. Return
```
ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Rules Example
With a bit more code in the `myFunc()` body:
```
int myFunc(int a, int b, int c) {
    int result;
    result = c;
    result += b;
    return result;
}

int main() {
    int x = 1, z = 3;
    int retVal = myFunc(x, 123, z);
    //...
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Rules Example (1)
```
section .text
myFunc:
                ; prologue
push ebp        ; save old base pointer
mov ebp, esp    ; set new base pointer
sub esp, 4      ; save room for 1 local var (result)
push ebx        ; save callee-save registers
push esi        ; both will be used by myFunc
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Rules Example (2)
```
                     ; subroutine body
mov eax, [ebp+8]     ; param 1 to eax
mov esi, [ebp+12]    ; param 2 to esi
mov ebx, [ebp+16]    ; param 3 to ebx
mov [ebp-4], ebx     ; put ebx into local var
add [ebp-4], esi     ; add esi into local var
mov eax, [ebp-4]     ; mov contents of local var to eax
                     ; (return value/final result)
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Callee Rules Example (3)
```
                ; subroutine epilogue
pop esi         ; recover callee save registers
pop ebx         ; REVERSE of when pushed
mov esp, ebp    ; deallocate local var(s)
pop ebp         ; restore caller's base pointer
ret             ; pop top value from stack, jump there
```
	  </script></section>

	  <section>
<h2>Stack Memory Visualization for myFunc</h2>
<p>This is just <i>after</i> the caller invokes the <code>call</code> opcode.</p>
<hr>
<table class="transparent">
<tr><td>&uarr;</td><td style="width:50px"></td><td class="border" style="width:300px">value of edx</td><td style="width:25px"></td><td>&#8598; ebp</td></tr>
<tr><td>To higher addresses</td><td style="width:50px"></td><td class="border" style="width:300px">copy of var z</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0xffffffff)</td><td style="width:50px"></td><td class="border" style="width:300px">123</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">value of eax (var x)</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">return address</td><td style="width:25px"></td><td>&larr; esp</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To lower addresses</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0x00000000)</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>&darr;</td><td style="width:50px"></td><td class="border" style="width:300px;border-bottom:medium solid;">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
</table>
	  </section>

	  <section data-transition="fade" data-transition-speed="fast">
<h2>Stack Memory Visualization for myFunc</h2>
<p>This is just after the callee invokes the <code>push ebp</code> opcode.</p>
<hr>
<table class="transparent">
<tr><td>&uarr;</td><td style="width:50px"></td><td class="border" style="width:300px">value of edx</td><td style="width:25px"></td><td>&#8598; ebp</td></tr>
<tr><td>To higher addresses</td><td style="width:50px"></td><td class="border" style="width:300px">copy of var z</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0xffffffff)</td><td style="width:50px"></td><td class="border" style="width:300px">123</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">value of eax (var x)</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">return address</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">ebp backup</td><td style="width:25px"></td><td>&larr; esp</td></tr>
<tr><td>To lower addresses</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>(to 0x00000000)</td><td style="width:50px"></td><td class="border" style="width:300px">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>&darr;</td><td style="width:50px"></td><td class="border" style="width:300px;border-bottom:medium solid;">&nbsp;</td><td style="width:25px"></td><td>&nbsp;</td></tr>
</table>
	  </section>

	  <section data-transition="fade" data-transition-speed="fast">
<h2>Stack Memory Visualization for myFunc</h2>
<p>This is after the <code>myFunc()</code> prologue is completed.</p>
<hr>
<table class="transparent">
<tr><td>&uarr;</td><td style="width:50px"></td><td class="border" style="width:300px">value of edx</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>To higher addresses</td><td style="width:50px"></td><td class="border" style="width:300px">copy of var z</td><td style="width:25px"></td><td>[ebp+16]</td></tr>
<tr><td>(to 0xffffffff)</td><td style="width:50px"></td><td class="border" style="width:300px">123</td><td style="width:25px"></td><td>[ebp+12]</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">value of eax (var x)</td><td style="width:25px"></td><td>[ebp+8]</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">return address</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td></td><td style="width:50px"></td><td class="border" style="width:300px">ebp backup</td><td style="width:25px"></td><td>&larr; ebp</td></tr>
<tr><td>To lower addresses</td><td style="width:50px"></td><td class="border" style="width:300px">local variable</td><td style="width:25px"></td><td>[ebp-4]</td></tr>
<tr><td>(to 0x00000000)</td><td style="width:50px"></td><td class="border" style="width:300px">saved value of ebx</td><td style="width:25px"></td><td>&nbsp;</td></tr>
<tr><td>&darr;</td><td style="width:50px"></td><td class="border" style="width:300px;border-bottom:medium solid;">saved value of esi</td><td style="width:25px"></td><td>&larr; esp</td></tr>
</table>
	  </section>

	  <section>
    <table class="transparent">
      <tr>
	<td>

	  <!-- code block table -->
	  <small>
	  <table class="transparent">
	    <tr><td><span style="font-size:larger">Code</span></td></tr>
	    <tr><td style="vertical-align:top">
		<table class="transparent" style="padding:0;spacing:0;border-spacing:0;border-collapse:collapse">
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>push ebp</code></pre></td>         <td><span class="fragment" data-fragment-index="1"><span class="fragment fade-out" data-fragment-index="3"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>mov ebp, esp</code></pre></td>     <td><span class="fragment" data-fragment-index="3"><span class="fragment fade-out" data-fragment-index="6"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>sub esp, 4</code></pre></td>       <td><span class="fragment" data-fragment-index="6"><span class="fragment fade-out" data-fragment-index="8"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>push ebx</code></pre></td>         <td><span class="fragment" data-fragment-index="8"><span class="fragment fade-out" data-fragment-index="10"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>push esi</code></pre></td>         <td><span class="fragment" data-fragment-index="10"><span class="fragment fade-out" data-fragment-index="12"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>mov eax, [ebp+8]</code></pre></td> <td><span class="fragment" data-fragment-index="12"><span class="fragment fade-out" data-fragment-index="14"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>mov esi, [ebp+12]</code></pre></td><td><span class="fragment" data-fragment-index="14"><span class="fragment fade-out" data-fragment-index="16"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>mov ebx, [ebp+16]</code></pre></td><td><span class="fragment" data-fragment-index="16"><span class="fragment fade-out" data-fragment-index="18"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>mov [ebp-4], ebx</code></pre></td> <td><span class="fragment" data-fragment-index="18"><span class="fragment fade-out" data-fragment-index="20"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>add [ebp-4], esi</code></pre></td> <td><span class="fragment" data-fragment-index="20"><span class="fragment fade-out" data-fragment-index="22"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>mov eax, [ebp-4]</code></pre></td> <td><span class="fragment" data-fragment-index="22"><span class="fragment fade-out" data-fragment-index="24"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>pop esi</code></pre></td>          <td><span class="fragment" data-fragment-index="24"><span class="fragment fade-out" data-fragment-index="26"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>pop ebx</code></pre></td>          <td><span class="fragment" data-fragment-index="26"><span class="fragment fade-out" data-fragment-index="28"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>mov esp, ebp</code></pre></td>     <td><span class="fragment" data-fragment-index="28"><span class="fragment fade-out" data-fragment-index="30"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>pop ebp</code></pre></td>          <td><span class="fragment" data-fragment-index="30"><span class="fragment fade-out" data-fragment-index="32"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		  <tr><td><pre style="margin-top:0px;margin-bottom:0px"><code>ret</code></pre></td>              <td><span class="fragment" data-fragment-index="32"><span class="fragment fade-out" data-fragment-index="100"><span style="font-size:larger">&larr;</span></span></span></td></tr>
		</table>
	    </td></tr>
	  </table>
	  </small>

	</td>
	<td>

	  <table class="transparent">
	    <tr><td colspan="3"><h2>Callee Animation</h2></td></tr>
	    <tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
	    <tr><td>Stack</td><td colspan="2">Registers</td></tr>
	    <tr>
	      <td style="vertical-align:top">
		<div style="position:relative;left:0;top:0">
		  <img alt="cc animation" class="fragment fade-out" data-fragment-index="2" src="x86/32bit/x86-cc-stack.dot.6.svg" style="position:relative;left:0px;top:0px">
		  <span class="fragment fade-out" data-fragment-index="7"><img alt="cc animation" class="fragment" data-fragment-index="2" src="x86/32bit/x86-cc-stack.dot.7.svg" style="position:absolute;left:0;top:0px"></span>
		  <span class="fragment fade-out" data-fragment-index="9"><img alt="cc animation" class="fragment" data-fragment-index="7" src="x86/32bit/x86-cc-stack.dot.8.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="11"><img alt="cc animation" class="fragment" data-fragment-index="9" src="x86/32bit/x86-cc-stack.dot.9.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="19"><img alt="cc animation" class="fragment" data-fragment-index="11" src="x86/32bit/x86-cc-stack.dot.10.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="21"><img alt="cc animation" class="fragment" data-fragment-index="19" src="x86/32bit/x86-cc-stack.dot.11.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="25"><img alt="cc animation" class="fragment" data-fragment-index="21" src="x86/32bit/x86-cc-stack.dot.12.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="27"><img alt="cc animation" class="fragment" data-fragment-index="25" src="x86/32bit/x86-cc-stack.dot.13.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="29"><img alt="cc animation" class="fragment" data-fragment-index="27" src="x86/32bit/x86-cc-stack.dot.14.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="31"><img alt="cc animation" class="fragment" data-fragment-index="29" src="x86/32bit/x86-cc-stack.dot.7.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="33"><img alt="cc animation" class="fragment" data-fragment-index="31" src="x86/32bit/x86-cc-stack.dot.6.svg" style="position:absolute;left:0;top:0"></span>
		  <img alt="cc animation" class="fragment" data-fragment-index="33" src="x86/32bit/x86-cc-stack.dot.5.svg" style="position:absolute;left:0;top:0">
		</div>
	      </td>
	      
	      <td style="vertical-align:top">
		<div style="position:relative;left:0;top:0">
		  <img alt="cc animation" class="fragment fade-out" data-fragment-index="2" src="x86/32bit/x86-cc-esp.dot.6.svg" style="position:relative;left:0;top:0">
		  <span class="fragment fade-out" data-fragment-index="4"><img alt="cc animation" class="fragment" data-fragment-index="2" src="x86/32bit/x86-cc-esp.dot.7.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="5"><img alt="cc animation" class="fragment" data-fragment-index="4" src="x86/32bit/x86-cc-esp.dot.8.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="7"><img alt="cc animation" class="fragment" data-fragment-index="5" src="x86/32bit/x86-cc-esp.dot.9.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="9"><img alt="cc animation" class="fragment" data-fragment-index="7" src="x86/32bit/x86-cc-esp.dot.10.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="11"><img alt="cc animation" class="fragment" data-fragment-index="9" src="x86/32bit/x86-cc-esp.dot.11.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="25"><img alt="cc animation" class="fragment" data-fragment-index="11" src="x86/32bit/x86-cc-esp.dot.12.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="27"><img alt="cc animation" class="fragment" data-fragment-index="25" src="x86/32bit/x86-cc-esp.dot.11.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="29"><img alt="cc animation" class="fragment" data-fragment-index="27" src="x86/32bit/x86-cc-esp.dot.10.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="31"><img alt="cc animation" class="fragment" data-fragment-index="29" src="x86/32bit/x86-cc-esp.dot.9.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="33"><img alt="cc animation" class="fragment" data-fragment-index="31" src="x86/32bit/x86-cc-esp.dot.6.svg" style="position:absolute;left:0;top:0"></span>
		  <img alt="cc animation" class="fragment" data-fragment-index="33" src="x86/32bit/x86-cc-esp.dot.5.svg" style="position:absolute;left:0;top:0">
		</div>
	      </td>

	      <td style="vertical-align:top">
		<div style="position:relative;left:0;top:0">
		  <img alt="cc animation" class="fragment fade-out" data-fragment-index="13" src="x86/32bit/x86-cc-regs.dot.svg" style="position:relative;left:0;top:0">
		  <span class="fragment fade-out" data-fragment-index="15"><img alt="cc animation" class="fragment" data-fragment-index="13" src="x86/32bit/x86-cc-regs.dot.2.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="17"><img alt="cc animation" class="fragment" data-fragment-index="15" src="x86/32bit/x86-cc-regs.dot.3.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="23"><img alt="cc animation" class="fragment" data-fragment-index="17" src="x86/32bit/x86-cc-regs.dot.4.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="25"><img alt="cc animation" class="fragment" data-fragment-index="23" src="x86/32bit/x86-cc-regs.dot.5.svg" style="position:absolute;left:0;top:0"></span>
		  <span class="fragment fade-out" data-fragment-index="27"><img alt="cc animation" class="fragment" data-fragment-index="25" src="x86/32bit/x86-cc-regs.dot.6.svg" style="position:absolute;left:0;top:0"></span>
		  <img alt="cc animation" class="fragment" data-fragment-index="27" src="x86/32bit/x86-cc-regs.dot.7.svg" style="position:absolute;left:0;top:0">
		</div>
	      </td>
	    </tr>
	  </table>

	</td>
      </tr>
    </table>
	  </section>


	</section>


	<section>

	  <section id="actrecs" data-markdown><script type="text/template">
# Activation Records
	  </script></section>

	  <section>
<h2>Activation Records</h2>
<table class="transparent"><tr>
<td class="top" style="width:50%">
<ul>
<li>Every time a sub-routine is called, a number of things are pushed onto the stack:<ul>
    <li>Registers</li>
    <li>Parameters</li>
    <li>Old base/stack pointers</li>
    <li>Local variables</li>
    <li>Return address</li>
</ul></li>
<li>All of this is called the <i>activation record</i><ul>
    <li>(note that caller-saved registers are not shown in this diagram)</li>
</ul></li>
</ul>
</td><td style="width:50%">
<img alt="x86 activation record" src="images/08-x86/x86-activation-record.svg">
</td></tr></table>
	  </section>

	  <section data-markdown><script type="text/template">
## Memory management
- The binary program takes up a fixed amount of space
  - The size of the file (say, 10k, as an example)
- There are two types of memory that need to be handled:
  - Dynamic memory (via `new`, `malloc()`, etc.)
    - This is stored on the *heap*
  - Static memory (on the stack)
    - This is where the activation records are kept
	  </script></section>

	  <section data-markdown><script type="text/template">
## Memory management
- The binary program starts at the beginning of the 2<sup>32</sup> = 4 Gb of memory
- The heap starts right after this
  - Say, at address 10,000 or so if you have a 10 kb binary file
- The stack starts at the end of this 4 Gb of memory, and grows backward
  - They could have chosen the heap to grow backwards, but they didn't
- As a program progresses, they both grow toward the middle
  - And never the two shall meet
	  </script></section>

	  <section>
<h2>Consider this subroutine</h2>
<pre><code>void security_hole() {
    char buffer[12];
    scanf ("%s", buffer); // how C handles input
}</code></pre>
<p>The stack looks like (with sizes in parenthesis):</p>
<table class="transparent" style="border-bottom:medium solid;"><tr>
  <td class="border">&nbsp;esi (4)&nbsp;</td>
  <td class="border">&nbsp;edi (4)&nbsp;</td>
  <td class="border">&nbsp;buffer (12)&nbsp;</td>
  <td class="border">&nbsp;ebp (4)&nbsp;</td>
  <td class="border">&nbsp;ret addr (4)&nbsp;</td>
</tr></table>
<ul>
<li>Addresses increase to the right (the stack grows to the left)</li>
<li class="fragment">What happens if the value stored into buffer is 13 bytes long?</li>
<li class="fragment">What happens if the value stored into buffer is 16 bytes long?</li>
<li class="fragment">What if it is exactly 20 bytes long?<ul>
    <li class="fragment">We overwrite the return address!</li>
</ul></li>
</ul>
	  </section>

	  <section data-markdown><script type="text/template">
## Buffer overflow attack
- When you read in a string (etc.) that goes beyond the size of the buffer
  - Hence 'buffer overflow'
- You can then overwrite the return address
  - And set it to your own code
  - For example, code that is included later on in the string
- We may see an example of this, if there is time in the course...
	  </script></section>

	</section>


	<section>

	  <section id="examples" data-markdown><script type="text/template">
# x86 Examples
	  </script></section>

	  <section data-markdown><script type="text/template">
## A note about x86 compatibility
- We are using nasm as our assembler for the x86 labs
- The x86 code samples in this slide set are either:
  - "Generic" x86 examples that could work in nasm if put into a proper program
    - In the same way that you have seen C++ code snippets
  - Or the output from "clang++ -S" or "g++ -S" (and probably some other flags)
    - This code will *NOT* work with nasm, but will work with clang++/g++ (which we aren't really using to compile our assembly anyway)
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 Examples
All examples are in the [slides/code/08-x86/](code/08-x86/) directory in the github repo  
&nbsp;  
Code we'll see:

- int absolute_value(int x)
- int max(int x, int y)
- bool compare_string(const char \*theStr1, const char \*theStr2)
- int fib(unsigned int n)
	  </script></section>

	  <section data-markdown><script type="text/template">
## clang++ creates some odd assembly...
- We'll see why later, but clang++ creates some odd-looking assembly
  - Which does not appear to follow the calling convention
- So you can use g++ to view the assembly
  - The flags are different:
```
g++ -S -m32 -masm=intel
```
  - g++ was installed on your VirtualBox image specifically for this reason
- The assembly shown in this slide set was generated using g++, not clang++
	  </script></section>

	  <section data-markdown><script type="text/template">
## int absolute_value(int x)
(see next slide for the source code link)
```
int absolute_value(int x) {
    if ( x < 0 )        // if x is negative
        x = -x;    // negate x
    return x;      // return x
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## test_abs.cpp
Source code: [test_abs.cpp](code/08-x86/test_abs.cpp.html) ([src](code/08-x86/test_abs.cpp))
```
#include <iostream>
using namespace std;
extern "C" int absolute_value(int x);

int absolute_value(int x) {
    if (x<0)	// if x is negative
        x = -x;	// negate x
    return x;	// return x
}

int main() {
    int theValue=0;
    cout << "Enter a value: " << endl;
    cin >> theValue;
    int theResult = absolute_value(theValue);
    cout << "The result is: " << theResult << endl;
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 Assembly for absolute_value
No external source code; this is how we might write it ourselves.
```
; Standard prologue
push ebp
mov ebp, esp

; procedure body
mov eax, [ebp + 8]    ; eax <- x
cmp eax, 0            ; x == 0 ?
jge end_of_proc       ; if pos goto end
neg eax               ; negate x

end_of_proc:
; Standard epilogue
mov esp, ebp
pop ebp
ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Generating assembly with clang++ or g++
- Using the -S flag, we can generate assembly from C/C++ code
- Note that the format is a bit different
  - Register specification, dest/source order, etc.
- So we need to use the following command:
```
clang++ -m32 -S test_abs.cpp -o test_abs-non-intel.s
```
  - You'll see why it has 'non-intel' in the name shortly...
- If you want to use g++ (which we do), you use:
```
g++ -m32 -S test_abs.cpp -o test_abs-non-intel.s
```
- The formatting is still slightly different from nasm, but the idea is the same
	  </script></section>

	  <section data-markdown><script type="text/template">
## g++'s assembly for absolute_value
Note the source / destination order is reversed!  And lots of other differences...

Source code: [test_abs-non-intel.s](code/08-x86/test_abs-non-intel.s.html) ([src](code/08-x86/test_abs-non-intel.s))
```
absolute_value:
	pushl   %eax
	movl    8(%esp), %eax
	movl    %eax, (%esp)
	cmpl    $0, (%esp)
	jge     .LBB1_2
	movl    $0, %eax
	subl    (%esp), %eax
	movl    %eax, (%esp)
.LBB1_2:
	movl    (%esp), %eax
	popl    %edx
	ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Assembly differences
- There are a lot of differences between the assembly we've seen and what `g++ -S` produces
  - `movl`, `pushl`, `cmpl`, `subl`, `popl`, etc.
    - the 'l' part means 'long' (i.e. 32 bits, so the assembler doesn't have to guess)
  - `$0` is the constant 0
  - Register names begin with a percent sign
  - `8(%ebp)` is [ebp+8]
    - i.e. where the parameters are
	  </script></section>

	  <section data-markdown><script type="text/template">
## Assembly syntax "flavors"
- There are two primary syntax "flavors" of x86 assmembly
  - The difference is solely in the formatting; all assembly commands can be written in either format
  - You can see more details about the differences [here](https://en.wikipedia.org/wiki/X86_assembly_language#Syntax)
- Flavors:
  - Intel syntax: what we will use, and what nasm uses
  - AT&T syntax: what `g++ -S` uses by default
- To make clang++ use the Intel syntax, you need to add the <br>`-mllvm --x86-asm-syntax=intel` flags
```
clang++ -m32 -mllvm --x86-asm-syntax=intel -S \
          test_abs.cpp -o test_abs.s
```
- For g++, use the `-masm=intel` flags:
```
g++ -m32 -masm=intel -S test_abs.cpp -o test_abs.s
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## g++'s assembly for absolute_value
This is with the `-masm=intel` flags

Source code: [test_abs.s](code/08-x86/test_abs.s.html) ([src](code/08-x86/test_abs.s))
```
absolute_value:
	push    ebp
	mov     ebp, esp
	cmp     DWORD PTR [ebp+8], 0
	jns     .L2
	neg     DWORD PTR [ebp+8]
.L2:
	mov     eax, DWORD PTR [ebp+8]
	pop     ebp
	ret
```
`jns` means jump if not signed (i.e. if positive)
	  </script></section>

	  <section data-markdown><script type="text/template">
## clang++'s assembly output on Macs
- With g++ (what we used last year), Darwin (i.e., Mac OS X) did not support the `-masm=intel` flag
  - And clang++ may not support the `-mllvm --x86-asm-syntax=intel` flags
- But I don't know what clang++ will do...
  - Can anybody test this?
- So you may be stuck using the "other" format
  - With the source / destination order reversed
- You can compile it on a the Linux VirtualBox image, if you want the 'correct' order
  - We recommned this for the x86 labs!
	  </script></section>

	  <section data-markdown><script type="text/template">
## test_abs_c.c
Source code: [test_abs_c.c](code/08-x86/test_abs_c.c.html) ([src](code/08-x86/test_abs_c.c))
```
#include <stdio.h>

int absolute_value(int x) {
    if ( x < 0 )      // if x is negative
        x = -x;   // negate x
    return x;     // return x
}

int main() {
    int theValue=0;
    printf ("Enter a value: \n");
    scanf ("%d", &theValue);
    int theResult = absolute_value(theValue);
    printf ("The result is: %d\n", theResult);
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## C++ assembly vs. C assembly
- Notice how much cleaner C translates into assembly versus C++
- Compare the absolute value code in both C and C++:
  - C++: [test_abs.s](code/08-x86/test_abs.s.html) ([src](code/08-x86/test_abs.s))
  - C: [test_abs_c.s](code/08-x86/test_abs_c.s.html) ([src](code/08-x86/test_abs_c.s))
	  </script></section>

	  <section data-markdown id="max"><script type="text/template">
## int max(int x, int y)
(see next slide for the source code link)
```
int max(int x, int y) {
    int theMax;
    if (x > y)        // if x > y then x is max
        theMax = x;
    else              // else y is the max
        theMax = y;
    return theMax;    // return the max
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## test_max.cpp
Source code: [test_max.cpp](code/08-x86/test_max.cpp.html) ([src](code/08-x86/test_max.cpp))
```
#include <iostream>
using namespace std;
extern "C" int max(int x, int y);

// the max function from the previous slide

int main() {
    int theValue1=0, theValue2=0;
    cout << "Enter value 1: " << endl;
    cin >> theValue1;
    cout << "Enter value 2: " << endl;
    cin >> theValue2;
    int theResult = max(theValue1, theValue2);
    cout << "The result is: " << theResult << endl;
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 code for max()
Using: `g++ -S -m32 -masm=intel`

Source code: [test_max.s](code/08-x86/test_max.s.html) ([src](code/08-x86/test_max.s))
```
max:
	push    ebp
	mov     ebp, esp
	sub     esp, 16
	mov     eax, DWORD PTR [ebp+8]
	cmp     eax, DWORD PTR [ebp+12]
	jle     .L2
	mov     eax, DWORD PTR [ebp+8]
	mov     DWORD PTR [ebp-4], eax
	jmp     .L3
.L2:
	mov     eax, DWORD PTR [ebp+12]
	mov     DWORD PTR [ebp-4], eax
.L3:
	mov     eax, DWORD PTR [ebp-4]
	leave
	ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 code for max() using -O2
Using: `g++ -S -m32 -masm=intel` and `-O2`

Source code: [test_max-O2.s](code/08-x86/test_max-O2.s.html) ([src](code/08-x86/test_max-O2.s))
```
max:
	mov     eax, DWORD PTR [esp+4]
	mov     edx, DWORD PTR [esp+8]
	cmp     edx, eax
	cmovge  eax, edx
	ret
```
The [cmovg](http://www.asmpedia.org/index.php?title=CMOVG) opcode (conditional move if greater than) will move the greater value into the first parameter; [cmovge](http://www.asmpedia.org/index.php?title=CMOVGE) does the move greater than *or equal to* value
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 code for max() without 'extern "C"'
Using: `g++ -S -m32 -masm=intel`

Source code: [test_max-noextern.s](code/08-x86/test_max-noextern.s.html) ([src](code/08-x86/test_max-noextern.s))
```
_Z3maxii:
	push   ebp
	mov    ebp, esp
	sub    esp, 16
	mov    eax, DWORD PTR [ebp+8]
	cmp    eax, DWORD PTR [ebp+12]
	jle    .L2
	mov    eax, DWORD PTR [ebp+8]
	mov    DWORD PTR [ebp-4], eax
	jmp    .L3
.L2:
	mov    eax, DWORD PTR [ebp+12]
	mov    DWORD PTR [ebp-4], eax
.L3:
	mov    eax, DWORD PTR [ebp-4]
	leave
	ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## C-string Comparison
(see next slide for the source code link)
```
bool compare_string (const char *theStr1, 
                     const char *theStr2) {
    // while *theStr1 is not NULL terminator
    // and the current corresponding bytes are equal
    while( (*theStr1 != NULL) 
            && (*theStr1 == *theStr2) ) {
        theStr1++;        // increment the pointers to 
        theStr2++;        // the next char / byte
    }
    return (*theStr1==*theStr2);
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## test_string_compare.cpp
Source code: [test_string_compare.cpp](code/08-x86/test_string_compare.cpp.html) ([src](code/08-x86/test_string_compare.cpp))
```
#include <iostream>
#include <string>
using namespace std;

extern "C" bool compare_string(const char* theStr1, 
                               const char* theStr2);

// code for compare_string here

int main() {
    string theValue1, theValue2;
    cout << "Enter string 1: " << endl;
    cin >> theValue1;
    cout << "Enter string 2: " << endl;
    cin >> theValue2;
    bool theResult = compare_string(theValue1.c_str(),
                                    theValue2.c_str());
    cout << "The result is: " << theResult << endl;
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 assembly for compare_string(), 1/3
Using: `g++ -S -m32 -masm=intel`

Source code: [test_string_compare.s](code/08-x86/test_string_compare.s.html) ([src](code/08-x86/test_string_compare.s))
```
compare_string:
	push    ebp
	mov     ebp, esp
	jmp     .L2
.L5:
	add     DWORD PTR [ebp+8], 1
	add     DWORD PTR [ebp+12], 1
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 assembly for compare_string(), 2/3
Using: `g++ -S -m32 -masm=intel`

Source code: [test_string_compare.s](code/08-x86/test_string_compare.s.html) ([src](code/08-x86/test_string_compare.s))
```
.L2:
	mov     eax, DWORD PTR [ebp+8]
	movzx   eax, BYTE PTR [eax]
	test    al, al
	je      .L3
	mov     eax, DWORD PTR [ebp+8]
	movzx   edx, BYTE PTR [eax]
	mov     eax, DWORD PTR [ebp+12]
	movzx   eax, BYTE PTR [eax]
	cmp     dl, al
	jne     .L3
	mov     eax, 1
	jmp     .L4
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 assembly for compare_string(), 3/3
Using: `g++ -S -m32 -masm=intel`

Source code: [test_string_compare.s](code/08-x86/test_string_compare.s.html) ([src](code/08-x86/test_string_compare.s))
```
.L3:
	mov     eax, 0
.L4:
	test    al, al
	jne     .L5
	mov     eax, DWORD PTR [ebp+8]
	movzx   edx, BYTE PTR [eax]
	mov     eax, DWORD PTR [ebp+12]
	movzx   eax, BYTE PTR [eax]
	cmp     dl, al
	sete    al
	pop     ebp
	ret
```
	  </script></section>

	  <section data-markdown id="fib"><script type="text/template">
## int fib
(see next slide for the source code link)
```
int fib(unsigned int n) {
    if ((n==0) || (n==1))
        return 1;
    return fib(n-1) + fib(n-2);
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## test_fib.cpp
Source code: [test_fib.cpp](code/08-x86/test_fib.cpp.html) ([src](code/08-x86/test_fib.cpp))
```
#include <iostream>
using namespace std;
extern "C" int fib(unsigned int n);

int fib(unsigned int n) {
    if ((n==0) || (n==1))
        return 1;
    return fib(n-1) + fib(n-2);
}

int main() {
    int theValue = 0;
    cout << "Enter value for fib(): " << endl;    
    cin >> theValue;
    int theResult = fib(theValue);
    cout << "The result is: " << theResult << endl;
    return 0;
}
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 assembly for fib(), 1/2
Using: `g++ -S -m32 -masm=intel`

Source code: [test_fib.s](code/08-x86/test_fib.s.html) ([src](code/08-x86/test_fib.s))
```
fib:
	push    ebp
	mov     ebp, esp
	push    ebx
	sub     esp, 20
	cmp     DWORD PTR [ebp+8], 0
	je      .L2
	cmp     DWORD PTR [ebp+8], 1
	jne     .L3
.L2:
	mov     eax, 1
	jmp     .L4
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## x86 assembly for fib(), 2/2
Using: `g++ -S -m32 -masm=intel`

Source code: [test_fib.s](code/08-x86/test_fib.s.html) ([src](code/08-x86/test_fib.s))
```
.L3:
	mov     eax, DWORD PTR [ebp+8]
	sub     eax, 1
	mov     DWORD PTR [esp], eax
	call    fib
	mov     ebx, eax
	mov     eax, DWORD PTR [ebp+8]
	sub     eax, 2
	mov     DWORD PTR [esp], eax
	call    fib
	add     eax, ebx
.L4:
	add     esp, 20
	pop     ebx
	pop     ebp
	ret
```
	  </script></section>

	  <section data-markdown><script type="text/template">
## Didn't that violate the convention?
- Not really!
- The convention states what the stack must look like when a subroutine is invoked
- The steps given in this slide set are to help learn the convention
- So as the stack was set up correctly, the convention was followed
	  </script></section>

	  <section>
<h2>Do we need to even use ebp?</h2>
<table class="transparent">
<tr><td class="top" style="width:50%">
<ul>
<li>If we know that the number of local variables will be fixed...<ul>
    <li>... then we can offset everything from esp instead</li>
</ul></li>
<li>This saves the push/pop ebp operations</li>
<li>clang++ really likes to do this...</li>
<li>But this is not always possible if a program uses dynamic memory on the <i>stack</i></li>
</ul>
</td><td class="top" style="width:50%"><img alt="x86 activation record" src="images/08-x86/x86-activation-record.svg"></td></tr></table>
	  </section>

	  <section data-markdown id="clangconventionbreak"><script type="text/template">
## But clang breaks the calling convention!
- Again, not really
- clang will optimize much of the calling convention away
  - For example, it will offset many things from esp (rather than ebp), and not bother to back up the caller's ebp
  - And if the subroutine invocation is solely within clang's code...
    - ... meaning that there is no call to an external library, or this is not code that will go *into* a library...
    - ... then parameters may be passed in the registers
	  </script></section>

	  <section data-markdown><script type="text/template">
## An aside: An advantage of little-Endian
- Consider the 32-bit big-Endian word 0x680abcde in memory starting address 1000:
  - In big-Endian:
    - Byte '68' is the most significant; is at address 1000
    - Byte 'de' is the least significant; is at address 1003
  - In little-Endian:
    - Byte 'de' is the most significant; is at address 1000
    - Byte '68' is the least significant; is at address 1003
- Note that, in little-Endian, the entire 32-bit word *and* the 8-bit least significant byte have the same address!
	  </script></section>

	  <section data-markdown><script type="text/template">
## More on little-Endian
- In little-Endian, the entire 32-bit word *and* the 8-bit least significant byte have the same address
- Consider a `movb`, `movw`, or `movl`
  - Moving a 8, 16, and 32 bit quantity, respecitively
  - If you called `movb`, that instruction moves the *least* significant 8 bits of the 32-bit quantity
- Thus, if you are doing one of those moves, the address is the *same*, which makes the CPU addressing routines simpler
- This means integer *casts* are a essentially a no-op
  - To cast an `int` to a `short`, you just tke lowest 16 bits, which means you use a `movw` instead of a `movl`
	  </script></section>

	  <section data-markdown><script type="text/template">
## RISC versus CISC
- RISC
  - Reduced instruction set computer
  - Fewer and simpler instructions (maybe 50 or so)
  - Less chip complexity means they can run fast
- CISC
  - Complex instruction set computer
  - More and more complex instructions (300-400 or so)
  - More chip complexity means harder to make run fast
	  </script></section>

    </section>



      </div>

    </div>

    <div id="calibratediv" style="display:none">
      <div id="calibratecanvasdiv">
        <canvas id="calibratecanvas" width="300" height="300">Your browser does not support the canvas tag</canvas>
      </div>
      <p style="text-align:center">Click the center of the target<br><a href="#" onClick="calibratewin.close(); return false">Close window</a></p>
    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.js"></script>
    <script src="js/settings.js"></script>

  </body>
</html>
